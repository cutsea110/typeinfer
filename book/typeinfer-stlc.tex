
この章から、本題である所の型推論について説明していきます。

\section{型推論とは}

型推論とは、項からその項の型を計算することです。

最近の多くの言語処理系はプログラムにおける型を計算するための型推論の機能を持っており、
一部のプログラマにとっても身近かつ必要不可欠な物となっているでしょう。

単純型付き $\lambda$ 計算の型推論が何をする物なのか、1章で説明した型判定を使って説明してみましょう。

仮に、型推論を任意の型環境 $\Gamma$ と任意の $\lambda$ 項 $e$ に対し、$\Gamma \vdash e : t$
であるような型 $t$ を計算する操作としてみましょう。

しかし、これには以下に示した2つの問題点があります。

\begin{enumerate}
  \item 型が付けられない $\lambda$ 項に関しては、解が存在しません。
  \item 無数の解が存在するケースがあります。例えば、型環境 $\emptyset$ の下で項 $\lambda x . x$ は
		$\alpha \to \alpha$ や $(\alpha \to \beta) \to \alpha \to \beta$ など、
		$?_0 \to ?_0$ の形を持つ型全てで型付けできます。
\end{enumerate}

まず、1番目は解があるか無いかを判定し、解がある場合のみ型を計算する物としましょう。

2番目に関しては、最も広い範囲を指す型の表現、つまり $\lambda x . x$ に対する $?_0 \to ?_0$
のような型を計算する物としましょう。

以上をまとめて、単純型付き $\lambda$ 計算の型推論を以下のように定義します。

\begin{definition}[単純型付き $\lambda$ 計算の型推論]
単純型付き $\lambda$ 計算の型推論は、任意の型環境 $\Gamma$ と任意の $\lambda$ 項 $e$ に対し、
$\Gamma \vdash e : t$ であるような型 $t$ が存在するかを計算する。
また、もしそのような型が存在するのであればその $t$ のうち最も広い範囲の型を計算する。
\end{definition}

この定義のような型推論は、決定可能であることが知られています。
型推論のアルゴリズムについて考えていきましょう。

\section{アルゴリズム}

型推論のアルゴリズムは、大きく分けて型に関する方程式の生成と、
その方程式を解く2つの部分によって構成されています。

ここでいう方程式とは、型の等式集合のことです。1章で出てきた実際に型を付けてみる例では、
とある型ととある型が同一であるという等式はその場で解いてしまっていましたが、
ここではまずこの等式集合を生成し、それを後から解くという方針を取ります。

型環境 $\emptyset$ の下で $\lambda f . f \, (f \, (\lambda x . x))$
という $\lambda$ 項がどのような型を持つか、という例で型の等式集合を作ってみましょう。

また、今までは証明木を構築する時に木の全体を書いていましたが、
今回は後から $?$ が書き変わることが無いので、その時点で見ている部分のみを書くことにしましょう。

まず、外側は $\lambda$ 抽象なので、
\[
  \infere{T-Abs}{
    \emptyset \vdash \lambda f . f \, (f \, (\lambda x . x)) : ?_0
  }{
    \{f : ?_1\} \vdash f \, (f \, (\lambda x . x)) : ?_2
  }
\]
となります。規則 \textsc{T-Abs} により、$?_0 = ?_1 \to ?_2$ という制約が追加されます。

次は関数適用なので、
\[
  \infere{T-App}{
    \{f : ?_1\} \vdash f \, (f \, (\lambda x . x)) : ?_2
  }{
    \{f : ?_1\} \vdash f : ?_3 \to ?_2 &
	\{f : ?_1\} \vdash f \, (\lambda x . x) : ?_3
  }
\]
となります。

次は右側の関数適用に注目すると、
\[
  \infere{T-App}{
    \{f : ?_1\} \vdash f \, (\lambda x . x) : ?_3
  }{
    \{f : ?_1\} \vdash f : ?_4 \to ?_3 &
    \{f : ?_1\} \vdash \lambda x . x : ?_4
  }
\]
となります。

次は右側の $\lambda$ 抽象に注目すると、
\[
  \infere{T-Abs}{
    \{f : ?_1\} \vdash \lambda x . x : ?_4
  }{
    \{f : ?_1, x : ?_5\} \vdash x : ?_6
  }
\]
となります。規則 \textsc{T-Abs} により、$?_4 = ?_5 \to ?_6$ という制約が追加されます。

残りは変数です。
まずは $\{f : ?_1\} \vdash f : ?_3 \to ?_2$ を解くと、
\[
  \infere{T-Var}{
    \{f : ?_1\} \vdash f : ?_3 \to ?_2
  }{
    \infere{T-Env1}{
	  f : ?_3 \to ?_2 \in \{f : ?_1\}
	}{}
  }
\]
となります。規則 \textsc{T-Env1} により、$?_3 \to ?_2 = ?_1$ という制約が追加されます。

$\{f : ?_1\} \vdash f : ?_4 \to ?_3$ を解くと、
\[
  \infere{T-Var}{
    \{f : ?_1\} \vdash f : ?_4 \to ?_3
  }{
    \infere{T-Env1}{
      f : ?_4 \to ?_3 \in \{f : ?_1\}
    }{}
  }
\]
となります。規則 \textsc{T-Env1} により、$?_4 \to ?_3 = ?_1$ という制約が追加されます。

$\{f : ?_1, x : ?_5\} \vdash x : ?_6$ を解くと、
\[
  \infere{T-Var}{
    \{f : ?_1, x : ?_5\} \vdash x : ?_6
  }{
    \infere{T-Env1}{
      x : ?_6 \in \{f : ?_1, x : ?_5\}
    }{}
  }
\]
となります。規則 \textsc{T-Env1} により、$?_6 = ?_5$ という制約が追加されます。

これで、方程式の生成ができました。等式を列挙すると
\begin{itemize}
  \item $?_0 = ?_1 \to ?_2$
  \item $?_4 = ?_5 \to ?_6$
  \item $?_3 \to ?_2 = ?_1$
  \item $?_4 \to ?_3 = ?_1$
  \item $?_6 = ?_5$
\end{itemize}
となっています。

方程式を解いた結果は $?_n$ とその実体の対応という形になるとしましょう。

まず、上から3つ分の制約を解きます。等式をそのまま入れれば良いので、結果は
$\{?_0 = ?_1 \to ?_2, ?_1 = ?_3 \to ?_2, ?_4 = ?_5 \to ?_6\}$
のようになります。

次に、$?_4 \to ?_3 = ?_1$ を解きます。まず、$?_1$ は $?_3 \to ?_2$ と同じなので、
この制約は $?_4 \to ?_3 = ?_3 \to ?_2$ と等価です。
どちらも $?_n$ でないような形の制約は、構造を解いて複数の制約に変えることで適用します。
この場合は、 $?_4 = ?_3$ と $?_3 = ?_2$ に分解します。

$?_4 = ?_3$ と $?_3 = ?_2$ を適用すると、
$\{?_0 = ?_1 \to ?_2, ?_1 = ?_3 \to ?_2, ?_2 = ?_3, ?_3 = ?_4, ?_4 = ?_5 \to ?_6\}$
となります。

最後の $?_6 = ?_5$ を適用すると、
$\{?_0 = ?_1 \to ?_2, ?_1 = ?_3 \to ?_2, ?_2 = ?_3, ?_3 = ?_4, ?_4 = ?_5 \to ?_6, ?_5 = ?_6\}$
となります。これで方程式は全て解けました。

元々解きたい物は $\emptyset \vdash \lambda f . f \, (f \, (\lambda x . x)) : ?_0$
となっているので、方程式の解の上で $?_0$ が何であるかを辿っていけば良いはずです。
これをやってみると、$(?_6 \to ?_6) \to ?_6 \to ?_6$ という型が得られます。

よって、型環境 $\emptyset$ の下で $\lambda f . f \, (f \, (\lambda x . x))$ は
$(\alpha \to \alpha) \to \alpha \to \alpha$ で型付けできるということが分かります。
また、他の型で型付け可能だとしても、それはこの型の $\alpha$ に対して別の型を代入した形を持ちます。

単純型付き $\lambda$ 計算の型推論は、このような方法で実現できます。
では、方程式の生成と制約解消系について、その詳細を順番に見ていきましょう。

\subsection{方程式の生成}

方程式の生成アルゴリズムを考えていきます。

まず、前提として今まで使ってきた $?_n$ のような
ユニークな型上の変数を無制限に作り出す仕組みがあると仮定しましょう。
また、この仕組みによって作られた型変数の事を\textbf{フレッシュな型変数}と呼びます。



\subsection{制約解消系}



\section{実装}



