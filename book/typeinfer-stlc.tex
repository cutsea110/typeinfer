
この章から、本題である所の型推論について説明していきます。

\section{型推論とは}

型推論とは、項からその項の型を計算することです。

最近の多くの言語処理系はプログラムにおける型を計算するための型推論の機能を持っており、
一部のプログラマにとっても身近かつ必要不可欠なものとなっているでしょう。

単純型付き $\lambda$ 計算の型推論が何をするのか、1章で説明した型判定を使って説明してみましょう。

仮に、型推論を任意の型環境 $\Gamma$ と任意の $\lambda$ 項 $e$ に対し、$\Gamma \vdash e : t$
であるような型 $t$ を計算する操作としてみましょう。

しかし、これには以下に示した2つの問題点があります。

\begin{enumerate}
  \item 型が付けられない $\lambda$ 項に関しては、解が存在しません。
  \item 無数の解が存在するケースがあります。例えば、型環境 $\emptyset$ の下で項 $\lambda x . x$ は
        $\alpha \to \alpha$ や $(\alpha \to \beta) \to \alpha \to \beta$ など、
        $?_0 \to ?_0$ の形を持つ型全てで型付けできます。
\end{enumerate}

まず、1番目は解があるかないかを判定し、解がある場合のみ型を計算するとしましょう。

2番目に関しては、最も広い範囲を指す型の表現、つまり $\lambda x . x$ に対する $?_0 \to ?_0$
のような型を計算するとしましょう。

以上をまとめて、単純型付き $\lambda$ 計算の型推論を以下のように定義します。

\begin{definition}[単純型付き $\lambda$ 計算の型推論]
単純型付き $\lambda$ 計算の型推論は、任意の型環境 $\Gamma$ と任意の $\lambda$ 項 $e$ に対し、
$\Gamma \vdash e : t$ であるような型 $t$ が存在するかを計算する。
また、もしそのような型が存在するのであればその $t$ のうち最も広い範囲の型を計算する。
\end{definition}

この定義のような型推論は、決定可能であることが知られています。
型推論のアルゴリズムについて考えていきましょう。

\section{アルゴリズム}

型推論のアルゴリズムは、大きく分けて型に関する方程式の生成と、
その方程式を解く2つの部分によって構成されています。

ここでいう方程式とは、型の等式集合のことです。1章で出てきた実際に型を付けてみる例では、
とある型ととある型が同一であるという等式はその場で解いてしまっていましたが、
ここではまずこの等式集合を生成し、それを後から解くという方針を取ります。

\subsection{例}

型推論のアルゴリズムの説明の前に、どうすれば型推論が実現できるのか、
特定の例を持ち出して考えてみましょう。

型環境 $\emptyset$ の下で $\lambda f . f \, (f \, (\lambda x . x))$
という $\lambda$ 項がどのような型を持つか、という例を用います。まずは型の等式集合を作ってみましょう。

また、今までは証明木を構築する時に木の全体を書いていましたが、
今回は後から $?$ が書き変わることがないので、その時点で見ている部分のみを書くことにしましょう。

まず、外側は $\lambda$ 抽象なので、
\[
  \infere{T-Abs}{
    \emptyset \vdash \lambda f . f \, (f \, (\lambda x . x)) : ?_0
  }{
    \{f : ?_1\} \vdash f \, (f \, (\lambda x . x)) : ?_2
  }
\]
となります。規則 \textsc{T-Abs} により、$?_0 = ?_1 \to ?_2$ という制約が追加されます。

次は関数適用なので、
\[
  \infere{T-App}{
    \{f : ?_1\} \vdash f \, (f \, (\lambda x . x)) : ?_2
  }{
    \{f : ?_1\} \vdash f : ?_3 \to ?_2 &
    \{f : ?_1\} \vdash f \, (\lambda x . x) : ?_3
  }
\]
となります。

次は右側の関数適用に注目すると、
\[
  \infere{T-App}{
    \{f : ?_1\} \vdash f \, (\lambda x . x) : ?_3
  }{
    \{f : ?_1\} \vdash f : ?_4 \to ?_3 &
    \{f : ?_1\} \vdash \lambda x . x : ?_4
  }
\]
となります。

次は右側の $\lambda$ 抽象に注目すると、
\[
  \infere{T-Abs}{
    \{f : ?_1\} \vdash \lambda x . x : ?_4
  }{
    \{f : ?_1, x : ?_5\} \vdash x : ?_6
  }
\]
となります。規則 \textsc{T-Abs} により、$?_4 = ?_5 \to ?_6$ という制約が追加されます。

残りは変数です。
まずは $\{f : ?_1\} \vdash f : ?_3 \to ?_2$ を解くと、
\[
  \infere{T-Var}{
    \{f : ?_1\} \vdash f : ?_3 \to ?_2
  }{
    \infere{T-Env1}{
      f : ?_3 \to ?_2 \in \{f : ?_1\}
    }{}
  }
\]
となります。規則 \textsc{T-Env1} により、$?_3 \to ?_2 = ?_1$ という制約が追加されます。

$\{f : ?_1\} \vdash f : ?_4 \to ?_3$ を解くと、
\[
  \infere{T-Var}{
    \{f : ?_1\} \vdash f : ?_4 \to ?_3
  }{
    \infere{T-Env1}{
      f : ?_4 \to ?_3 \in \{f : ?_1\}
    }{}
  }
\]
となります。規則 \textsc{T-Env1} により、$?_4 \to ?_3 = ?_1$ という制約が追加されます。

$\{f : ?_1, x : ?_5\} \vdash x : ?_6$ を解くと、
\[
  \infere{T-Var}{
    \{f : ?_1, x : ?_5\} \vdash x : ?_6
  }{
    \infere{T-Env1}{
      x : ?_6 \in \{f : ?_1, x : ?_5\}
    }{}
  }
\]
となります。規則 \textsc{T-Env1} により、$?_6 = ?_5$ という制約が追加されます。

これで、方程式の生成ができました。等式を列挙すると
\begin{itemize}
  \item $?_0 = ?_1 \to ?_2$
  \item $?_4 = ?_5 \to ?_6$
  \item $?_3 \to ?_2 = ?_1$
  \item $?_4 \to ?_3 = ?_1$
  \item $?_6 = ?_5$
\end{itemize}
となっています。

方程式を解いた結果は $?_n$ とその実体の対応という形になるとしましょう。
これを\textbf{代入 (substitution)} といいます。
これを $[?_a := t_a, ?_b := t_b , \dots]$ のように表記します。
項に出現する特定の自由変数を全て特定の項で置き換える操作も代入と呼ばれますが、
別のものであるということに注意してください。

方程式を解く操作は、等式集合と代入のペアを適切に変換することによって実現します。
最初の状態は、与えられた等式集合と空の代入のペアです。

では実際に書き換えを行ってみましょう。以下に書き換えの手順を示します。

\begin{enumerate}
  \item
    \begin{description}
      \item[等式集合]
        $\{?_0 = ?_1 \to ?_2, ?_4 = ?_5 \to ?_6, ?_3 \to ?_2 = ?_1, ?_4 \to ?_3 = ?_1, ?_6 = ?_5\}$
      \item[代入]
        $[]$
    \end{description}
    等式 $?_0 = ?_1 \to ?_2$ を解きます。
    一方が変数なので、等式集合と代入の $?_0$ を全て $?_1 \to ?_2$ に置き換え、
    代入に $?_0 := ?_1 \to ?_2$ を追加します。
  \item
    \begin{description}
      \item[等式集合]
        $\{?_4 = ?_5 \to ?_6, ?_3 \to ?_2 = ?_1, ?_4 \to ?_3 = ?_1, ?_6 = ?_5\}$
      \item[代入]
        $[?_0 := ?_1 \to ?_2]$
    \end{description}
    等式 $?_4 = ?_5 \to ?_6$ を解きます。
    一方が変数なので、等式集合と代入の $?_4$ を全て $?_5 \to ?_6$ に置き換え、
    代入に $?_4 := ?_5 \to ?_6$ を追加します。
  \item
    \begin{description}
      \item[等式集合]
        $\{?_3 \to ?_2 = ?_1, (?_5 \to ?_6) \to ?_3 = ?_1, ?_6 = ?_5\}$
      \item[代入]
        $[?_0 := ?_1 \to ?_2, ?_4 := ?_5 \to ?_6]$
    \end{description}
    等式 $?_3 \to ?_2 = ?_1$ を解きます。
    一方が変数なので、等式集合と代入の $?_1$ を全て $?_3 \to ?_2$ に置き換え、
    代入に $?_1 := ?_3 \to ?_2$ を追加します。
  \item
    \begin{description}
      \item[等式集合]
        $\{(?_5 \to ?_6) \to ?_3 = ?_3 \to ?_2, ?_6 = ?_5\}$
      \item[代入]
        $[?_0 := (?_3 \to ?_2) \to ?_2, ?_1 := ?_3 \to ?_2, ?_4 := ?_5 \to ?_6]$
    \end{description}
    等式 $(?_5 \to ?_6) \to ?_3 = ?_3 \to ?_2$ を解きます。
    どちらも関数の型なので、$?_5 \to ?_6 = ?_3$ と $?_3 = ?_2$ の2つの等式に分解します。
  \item
    \begin{description}
      \item[等式集合]
        $\{?_5 \to ?_6 = ?_3, ?_3 = ?_2, ?_6 = ?_5\}$
      \item[代入]
        $[?_0 := (?_3 \to ?_2) \to ?_2, ?_1 := ?_3 \to ?_2, ?_4 := ?_5 \to ?_6]$
    \end{description}
    等式 $?_5 \to ?_6 = ?_3$ を解きます。
    一方が変数なので、等式集合と代入の $?_3$ を全て $?_5 \to ?_6$ に置き換え、
    代入に $?_3 := ?_5 \to ?_6$ を追加します。
  \item
    \begin{description}
      \item[等式集合]
        $\{?_5 \to ?_6 = ?_2, ?_6 = ?_5\}$
      \item[代入]
        $[?_0 := ((?_5 \to ?_6) \to ?_2) \to ?_2, ?_1 := (?_5 \to ?_6) \to ?_2,
          ?_3 := ?_5 \to ?_6, ?_4 := ?_5 \to ?_6]$
    \end{description}
    等式 $?_5 \to ?_6 = ?_2$ を解きます。
    一方が変数なので、等式集合と代入の $?_2$ を全て $?_5 \to ?_6$ に置き換え、
    代入に $?_2 := ?_5 \to ?_6$ を追加します。
  \item
    \begin{description}
      \item[等式集合]
        $\{?_6 = ?_5\}$
      \item[代入]
        $[?_0 := ((?_5 \to ?_6) \to ?_5 \to ?_6) \to ?_5 \to ?_6,
          ?_1 := (?_5 \to ?_6) \to ?_5 \to ?_6, ?_2 := ?_5 \to ?_6, ?_3 := ?_5 \to ?_6,
          ?_4 := ?_5 \to ?_6]$
    \end{description}
    等式 $?_6 = ?_5$ を解きます。
    一方が変数なので、等式集合と代入の $?_6$ を全て $?_5$ に置き換え、
    代入に $?_6 := ?_5$ を追加します。
  \item
    \begin{description}
      \item[等式集合]
        $\{\}$
      \item[代入]
        $[?_0 := ((?_5 \to ?_5) \to ?_5 \to ?_5) \to ?_5 \to ?_5,
          ?_1 := (?_5 \to ?_5) \to ?_5 \to ?_5, ?_2 := ?_5 \to ?_5, ?_3 := ?_5 \to ?_5,
          ?_4 := ?_5 \to ?_5, ?_6 := ?_5]$
    \end{description}
    等式集合が空になったので、これで方程式が解けました。
\end{enumerate}

目的の型は $\emptyset \vdash \lambda f . f \, (f \, (\lambda x . x)) : ?_0$ とあることから分かる通り
$?_0$ なので、代入から $?_0$ に対応する型を取れば良いはずです。
よって、型環境 $\emptyset$ の下で項 $\lambda f . f \, (f \, (\lambda x . x))$ は
$((\alpha \to \alpha) \to \alpha \to \alpha) \to \alpha \to \alpha$ で型付けできると分かります。
また、他の型で型付けできるとしても、それはこの型の $\alpha$ に別の型を代入した形を持ちます。

単純型付き $\lambda$ 計算の型推論は、このような方法で実現できます。
では、方程式の生成と制約解消系について、その詳細を順番に見ていきましょう。

\subsection{方程式の生成}

方程式の生成アルゴリズムを考えていきます。

まず、前提として今まで使ってきた $?_n$ のような
ユニークな型上の変数を無制限に作り出す仕組みがあると仮定しましょう。
また、この仕組みによって作られた型変数のことを\textbf{フレッシュな型変数}と呼びます。

方程式を生成するアルゴリズムの名前を $\mathcal C$ としましょう
\footnote{constraints の c から取りました。}。
このアルゴリズムは、型環境 $\Gamma$ と項 $e$ を取り、方程式と項 $e$ の型を返すものとします。
また、項 $e$ の自由変数とその型は型環境 $\Gamma$ に含まれていなければならないものとします。

まず、$\mathcal C$ が型環境 $\Gamma$ と変数の項 $x$ を取る場合を考えます。
この場合は方程式は空で、型環境 $\Gamma$ から $x$ に対応する型を探して返します。

次に、$\mathcal C$ が型環境 $\Gamma$ と関数適用の項 $e_1 \, e_2$ を取る場合を考えます。
この場合はまず、$e_1$ と $e_2$ それぞれに関して $\mathcal C$ を適用します。
適用した結果が $(c_1, t_1) = \mathcal{C}(\Gamma, e_1)$ と $(c_2, t_2) = \mathcal{C}(\Gamma, e_2)$
のようになるとします。

さて、$e_1 \, e_2$ の型は何になるでしょうか。
$t_1$ でも $t_2$ でもないことは明らかなので、フレッシュな型変数 $t_3$ を作り、これを結果としましょう。
$e_1 : t_1$ は $e_2 : t_2$ を引数に取り $e_1 \, e_2 : t_3$ を返すので、
この3つの型の間に $t_1 = t_2 \to t_3$ という等式が成り立つはずです。これが新しい制約です。
方程式全体は単純に足せば良いので、$c_1 \cup c_2 \cup \{t_1 = t_2 \to t_3\}$ と表せます。
\footnote{$A \cup B$ は集合 $A$ と集合 $B$ の和集合のことです。}

次に、$\mathcal C$ が型環境 $\Gamma$ と $\lambda$ 抽象の項 $\lambda x . e$ を取る場合を考えます。
この場合はまず、フレッシュな型変数 $t_1$ を作り、
型環境 $\Gamma, x : t_1$ と項 $e$ に計算 $\mathcal C$ を適用します。
適用した結果が $(c, t_2) = \mathcal{C}(\Gamma, x : t_1, e)$ のようになるとします。
とくに追加する制約はないので、結果の方程式は $c$、$\lambda x . e$ の型は $t_1 \to t_2$ となります。

以上をまとめると、方程式の生成アルゴリズム $\mathcal C$ は図\ref{fig:algorithm-c}のようになります。

\begin{figure}[htbp]
 \begin{align*}
  \mathcal{C}(\Gamma, x) &=
   \mathrm{if} ~ x \notin \mathit{dom}(\Gamma) ~
   \mathrm{then} ~ \mathit{failure} ~
   \mathrm{else} ~ (\emptyset, \Gamma(x)) \\
  \mathcal{C}(\Gamma, e_1 \, e_2) &=
  \begin{array}[t]{l}
   \mathrm{let}
    \begin{array}[t]{l}
     (c_1, t_1) = \mathcal{C}(\Gamma, e_1) \\
     (t_2, t_2) = \mathcal{C}(\Gamma, e_2) \\
     t_3 = \mathrm{fresh}
    \end{array} \\
   \mathrm{in} (c_1 \cup c_2 \cup \{t_1 = t_2 \to t_3\}, t_3)
  \end{array} \\
  \mathcal{C}(\Gamma, \lambda x . e) &=
  \begin{array}[t]{l}
   \mathrm{let}
    \begin{array}[t]{l}
     t_1 = \mathrm{fresh} \\
     (c, t_2) = \mathcal{C}((\Gamma, x : t_1), e)
    \end{array} \\
   \mathrm{in} (c, t_1 \to t_2)
  \end{array}
 \end{align*}
 \caption{方程式の生成アルゴリズム $\mathcal C$}
 \label{fig:algorithm-c}
\end{figure}

この再帰的なアルゴリズム $\mathcal C$ は、項に関する構造的帰納法を使って記述できます。

また、
自由変数とその型は全て型環境に含まれているということの検査を含んでいるということに注意してください。
もしこの点が守られていなければ、$\mathit{failure}$ が返ります。
また、$\mathit{dom}(\Gamma)$ は型環境 $\Gamma$ の中の変数全ての集合を表します。
$\Gamma(x)$ というのは型環境 $\Gamma$ から $x$ の型を取ってくることを表します。
$\mathrm{fresh}$ はフレッシュな型変数を表します。

定数などを含む単純型付き $\lambda$ 計算に対しても、
同様の方法で対応するルールに沿うように制約の計算方法を追加することで正しい方程式の生成ができます。

このアルゴリズムによって生成される方程式を解くことで、単純型付き $\lambda$ 計算の型推論ができます。

\subsection{制約解消系}

次に、アルゴリズム $\mathcal C$ で生成した方程式を解くアルゴリズムについて考えます。

方程式を解くアルゴリズムの名前を $\mathcal U$ としましょう
\footnote{unification の u から取りました。}。
この計算は、等式集合を取り、それを解いた結果として得られる型変数への代入を返すとしましょう。
このアルゴリズムにおいて、等式 $t_1 = t_2$ と $t_2 = t_1$ は同一のものであるとします。

また、$S = \mathcal{U}(E)$ であるなら、
$E$ 中の任意の等式 $t_1 = t_2$ について $t_1 S = t_2 S$ が成り立つものとします。
このようなアルゴリズムを、\textbf{単一化 (unification)}のアルゴリズムといいます。

この節の頭で示した例での方針に従い、等式集合と代入の組の適切な変形規則を作り、
その変形の繰り返しによって得られる代入を結果とします。

まず、等式集合が $t = t$ と残りの等式集合に分割できる場合を考えます。
任意の代入は $t = t$ を満たすと考えられるので、これは単に $t = t$ を取り除けば良いはずです。よって、
\[
  (E \cup \{t = t\}, S) \Longrightarrow (E, S)
\]
という変形ができます。

次に、等式集合が $\alpha = t$ と残りの等式集合に分割できる場合を考えます。
この場合は、残りの等式と代入に出現する $\alpha$ を全て $t$ に置き換え、
代入に $\alpha := t$ を追加すれば良いはずです。よって、
\[
  (E \cup \{\alpha = t\}, S) \Longrightarrow (E[\alpha := t], S[\alpha := t] \cup [\alpha := t])
\]
という変形ができます。

ただし、$t$ の中に $\alpha$ が出現している場合、
置き換えの結果としてまた $\alpha$ が出てきてしまうので、$\alpha \notin \mathit{FTV}(t)$
でなければなりません。$\mathit{FTV}(t)$ は型 $t$ 中の型変数の集合を意味します。
これは free type variables の頭文字を取っています。

もし仮に $\alpha \in \mathit{FTV}(t)$ かつ $t \neq \alpha$ であったとすると、
$t$ は無限長の型になってしまうはずです。
しかし、型は帰納的に定義されているので、このことからも解が存在しないと言えます。

次に、等式集合が $t_1 \to t_2 = t_1' \to t_2'$ と残りの等式集合に分割できる場合を考えます。
この等式は、$t_1 = t_1'$ と $t_2 = t_2'$ という2つの等式に分割できると考えられます。
よって、
\[
  (E \cup \{t_1 \to t_2 = t_1' \to t_2'\}, S) \Longrightarrow (E \cup \{t_1 = t_1', t_2 = t_2'\}, S)
\]
という変形ができます。

以上で、変形規則は全てです。
単一化アルゴリズムの変形規則を、図\ref{fig:unification-trans}のように定義します。

\begin{figure}[htbp]
  \begin{align*}
    (E \cup \{t = t\}, S)
      &\Longrightarrow (E, S) \\
    (E \cup \{\alpha = t\}, S)
      &\Longrightarrow (E[\alpha := t], S[\alpha := t] \cup [\alpha := t])
      &\text{($\alpha \notin \mathit{FTV(t)}$)}\\
    (E \cup \{t_1 \to t_2 = t_1' \to t_2'\}, S)
      &\Longrightarrow (E \cup \{t_1 = t_1', t_2 = t_2'\}, S)
  \end{align*}
  \caption{単一化アルゴリズムの変形規則}
  \label{fig:unification-trans}
\end{figure}

また、この変形を0回以上の任意の回数繰り返す変形を、$\Longrightarrow^*$ で表現します。
この変形を用いて、アルゴリズム $\mathcal U$ を図\ref{fig:algorithm-u} のように定義します。

\begin{figure}[htbp]
  \begin{align*}
    U(E) &=
    \begin{cases}
      S & \text{($(E, \{\}) \Longrightarrow^* (\{\}, S)$)} \\
      \mathit{failure} & \text{(上記以外)}
    \end{cases}
  \end{align*}
  \caption{単一化アルゴリズム $\mathcal U$}
  \label{fig:algorithm-u}
\end{figure}

このアルゴリズムの停止性は、容易には説明ができません。
念のため、どのような理由でこのアルゴリズムが停止するのか考えてみましょう。



\section{実装}

ここまでで説明したアルゴリズムを OCaml で実装して、動かしてみましょう。

\subsection{データ型}

型推論を書く前に、その対象となる項と型を表現するデータ型を定義しましょう。

まずは、項のデータ型を定義します。項の定義は図\ref{fig:lambda-term}の通りです。
これを定義するとリスト\ref{list:ocaml-def-term}のようになります。

\begin{lstlisting}[caption=項の定義, label=list:ocaml-def-term]
type term
  = EVar of string
  | EApp of (term * term)
  | EAbs of (string * term)
;;
\end{lstlisting}

OCaml のデータ型定義は、\texttt{type} キーワードによって行います。
この定義では、\texttt{term} という型を定義しています。
その型コンストラクタは3種類あり、\texttt{EVar} コンストラクタは \texttt{string} 型の値を取り、
\texttt{EApp} コンストラクタは \texttt{term * term} 型の値を取り、
\texttt{EAbs} コンストラクタは \texttt{string * term} 型の値を取ります。
これらのコンストラクタは、それぞれ変数、関数適用、$\lambda$ 抽象に対応しています。
変数は文字列(\texttt{string})型を使っています。

型の中にある \texttt{*} はタプルの型です。\texttt{t1 * t2 * ... * tn} とすると
\texttt{t1}, \texttt{t2}, \dots, \texttt{tn} という型のタプルが作れます。

型のデータ型を定義しましょう。型の定義は図\ref{fig:stlc-type}の通りです。
これを定義するとリスト\ref{list:ocaml-def-type}のようになります。

\begin{lstlisting}[caption=型の定義, label=list:ocaml-def-type]
type ty
  = TFun of (ty * ty)
  | TVar of int
;;
\end{lstlisting}

\texttt{type} は OCaml のキーワードなので、\texttt{ty} という名前で型を定義しました。
\texttt{TFun} が関数の型のコンストラクタで、\texttt{TVar} が型変数の型のコンストラクタです。
型変数の実体は \texttt{int} 型(整数型)です。

次に、制約、型環境、代入の型を定義します。

制約は型上の等式なので、2つの型のタプルで表現できます。
制約を定義すると、リスト\ref{list:ocaml-def-tconst}のようになります。

\begin{lstlisting}[caption=制約の定義, label=list:ocaml-def-tconst]
type tconst = ty * ty;;
\end{lstlisting}

これは、\texttt{ty * ty} という型を、\texttt{tconst} という名前に紐付けています。
型や項の定義と違い、単なる型のエイリアスになっています。

型環境は変数と型のペアの並びのような形を持っていますが、
元々ある変数が後から追加されれば、それを参照することはありません。
つまり、変数から型へのマップ構造を使うことができます。

変数は文字列型を持つので、文字列から型へのマップ構造が必要となります。
文字列のマップは、core ライブラリの \texttt{Core.Std.String.Map} モジュールにあります。
これを使って型環境を定義すると、リスト\ref{list:ocaml-def-type-environment}のようになります。

\begin{lstlisting}[caption=型環境の定義, label=list:ocaml-def-type-environment]
module StrMap = Core.Std.String.Map;;
type assump = ty StrMap.t;;
\end{lstlisting}

\texttt{Core.Std.String.Map} というモジュール名は長いので、
1行目で \texttt{StrMap} という別名を付けています。

2行目で、\texttt{ty StrMap.t} 型を \texttt{assump} という名前に結び付けています。
\texttt{StrMap.t} という型は、\texttt{StrMap} モジュール内の \texttt{t} という型を指していますが、
これが文字列からのマップ型となっています。型引数として文字列に対応付ける型を取るので、
\texttt{ty StrMap.t} と書くと文字列から型へのマップの型になります。

代入は型変数から型へのマップ構造です。
型変数は整数型を持つので、整数から型へのマップ構造が必要となります。
整数のマップは、core ライブラリの \texttt{Core.Std.Int.Map} モジュールにあります。
これを使って代入を定義すると、リスト\ref{list:ocaml-def-substitution}のようになります。

\begin{lstlisting}[caption=代入の定義, label=list:ocaml-def-substitution]
module IntMap = Core.Std.Int.Map;;
type subst = ty IntMap.t;;
\end{lstlisting}

ここでも型環境の定義と同様に、
\texttt{Core.Std.Int.Map} モジュールに \texttt{IntMap} という別名を付けています。
\texttt{ty IntMap.t} 型に \texttt{subst} という別名を付けていますが、これが代入の型です。

\subsection{方程式の生成}

\begin{lstlisting}[caption=方程式を生成する関数, label=list:ocaml-stlc-infer]
let rec infer (n : int) (env : assump) :
    term -> (int * tconst list * ty) option =
  function
    | EVar str ->
      begin match StrMap.find env str with
        | Some v -> Some (n, [], v)
        | None -> None
      end
    | EApp (term1, term2) ->
      begin match infer (succ n) env term1 with
        | Some (n1, c1, t1) ->
          begin match infer n1 env term2 with
            | Some (n2, c2, t2) ->
              let tn = TVar n in
              Some (n2, (t1, TFun (t2, tn)) :: c1 @ c2, tn)
            | None -> None
          end
        | None -> None
      end
    | EAbs (ident, term) ->
      begin
        let tn = TVar n in
        match infer (succ n) (StrMap.add ident tn env) term with
          | Some (n', c, t) -> Some (n', c, TFun (tn, t))
          | None -> None
      end
;;
\end{lstlisting}

\subsection{制約解消系}

\begin{lstlisting}[caption=出現検査, label=list:ocaml-stlc-occurs-check]
let rec occurs_check env n =
  function
    | TVar n' ->
      begin match IntMap.find env n' with
        | Some t -> occurs_check env n t
        | None -> n = n'
      end
    | TFun (tl, tr) ->
      occurs_check env n tl || occurs_check env n tr
;;
\end{lstlisting}

\begin{lstlisting}[caption=方程式を解く関数, label=list:ocaml-stlc-solve]
let rec solve (env : subst) : tconst -> subst option =
  function
    | TVar n, TVar n' when n = n' -> Some env
    | TVar n, t | t, TVar n ->
      begin match IntMap.find env n with
        | Some t' -> solve env (t, t')
        | None when occurs_check env n t -> None
        | None -> Some (IntMap.add n t env)
      end
    | TFun (t1l, t1r), TFun (t2l, t2r) ->
      begin match solve env (t1l, t2l) with
        | Some env' -> solve env' (t1r, t2r)
        | None -> None
      end
;;
\end{lstlisting}

