
この章から、本題である所の型推論について説明していきます。

\section{型推論とは}

型推論とは、項からその項の型を計算することです。

最近の多くの言語処理系はプログラムにおける型を計算するための型推論の機能を持っており、
一部のプログラマにとっても身近かつ必要不可欠なものとなっているでしょう。

単純型付き $\lambda$ 計算の型推論が何をするのか、1章で説明した型判定を使って説明してみましょう。

仮に、型推論を任意の型環境 $\Gamma$ と任意の $\lambda$ 項 $e$ に対し、$\Gamma \vdash e : t$
であるような型 $t$ を計算する操作としてみましょう。

しかし、これには以下に示した2つの問題点があります。

\begin{enumerate}
  \item 型が付けられない $\lambda$ 項に関しては、解が存在しません。
  \item 無数の解が存在するケースがあります。例えば、型環境 $\emptyset$ の下で項 $\lambda x . x$ は
        $\alpha \to \alpha$ や $(\alpha \to \beta) \to \alpha \to \beta$ など、
        $?_0 \to ?_0$ の形を持つ型全てで型付けできます。
\end{enumerate}

まず、1番目は解があるか無いかを判定し、解がある場合のみ型を計算するとしましょう。

2番目に関しては、最も広い範囲を指す型の表現、つまり $\lambda x . x$ に対する $?_0 \to ?_0$
のような型を計算するとしましょう。

以上をまとめて、単純型付き $\lambda$ 計算の型推論を以下のように定義します。

\begin{definition}[単純型付き $\lambda$ 計算の型推論]
単純型付き $\lambda$ 計算の型推論は、任意の型環境 $\Gamma$ と任意の $\lambda$ 項 $e$ に対し、
$\Gamma \vdash e : t$ であるような型 $t$ が存在するかを計算する。
また、もしそのような型が存在するのであればその $t$ のうち最も広い範囲の型を計算する。
\end{definition}

この定義のような型推論は、決定可能であることが知られています。
型推論のアルゴリズムについて考えていきましょう。

\section{アルゴリズム}

型推論のアルゴリズムは、大きく分けて型に関する方程式の生成と、
その方程式を解く2つの部分によって構成されています。

ここでいう方程式とは、型の等式集合のことです。1章で出てきた実際に型を付けてみる例では、
とある型ととある型が同一であるという等式はその場で解いてしまっていましたが、
ここではまずこの等式集合を生成し、それを後から解くという方針を取ります。

型環境 $\emptyset$ の下で $\lambda f . f \, (f \, (\lambda x . x))$
という $\lambda$ 項がどのような型を持つか、という例で型の等式集合を作ってみましょう。

また、今までは証明木を構築する時に木の全体を書いていましたが、
今回は後から $?$ が書き変わることが無いので、その時点で見ている部分のみを書くことにしましょう。

まず、外側は $\lambda$ 抽象なので、
\[
  \infere{T-Abs}{
    \emptyset \vdash \lambda f . f \, (f \, (\lambda x . x)) : ?_0
  }{
    \{f : ?_1\} \vdash f \, (f \, (\lambda x . x)) : ?_2
  }
\]
となります。規則 \textsc{T-Abs} により、$?_0 = ?_1 \to ?_2$ という制約が追加されます。

次は関数適用なので、
\[
  \infere{T-App}{
    \{f : ?_1\} \vdash f \, (f \, (\lambda x . x)) : ?_2
  }{
    \{f : ?_1\} \vdash f : ?_3 \to ?_2 &
    \{f : ?_1\} \vdash f \, (\lambda x . x) : ?_3
  }
\]
となります。

次は右側の関数適用に注目すると、
\[
  \infere{T-App}{
    \{f : ?_1\} \vdash f \, (\lambda x . x) : ?_3
  }{
    \{f : ?_1\} \vdash f : ?_4 \to ?_3 &
    \{f : ?_1\} \vdash \lambda x . x : ?_4
  }
\]
となります。

次は右側の $\lambda$ 抽象に注目すると、
\[
  \infere{T-Abs}{
    \{f : ?_1\} \vdash \lambda x . x : ?_4
  }{
    \{f : ?_1, x : ?_5\} \vdash x : ?_6
  }
\]
となります。規則 \textsc{T-Abs} により、$?_4 = ?_5 \to ?_6$ という制約が追加されます。

残りは変数です。
まずは $\{f : ?_1\} \vdash f : ?_3 \to ?_2$ を解くと、
\[
  \infere{T-Var}{
    \{f : ?_1\} \vdash f : ?_3 \to ?_2
  }{
    \infere{T-Env1}{
      f : ?_3 \to ?_2 \in \{f : ?_1\}
    }{}
  }
\]
となります。規則 \textsc{T-Env1} により、$?_3 \to ?_2 = ?_1$ という制約が追加されます。

$\{f : ?_1\} \vdash f : ?_4 \to ?_3$ を解くと、
\[
  \infere{T-Var}{
    \{f : ?_1\} \vdash f : ?_4 \to ?_3
  }{
    \infere{T-Env1}{
      f : ?_4 \to ?_3 \in \{f : ?_1\}
    }{}
  }
\]
となります。規則 \textsc{T-Env1} により、$?_4 \to ?_3 = ?_1$ という制約が追加されます。

$\{f : ?_1, x : ?_5\} \vdash x : ?_6$ を解くと、
\[
  \infere{T-Var}{
    \{f : ?_1, x : ?_5\} \vdash x : ?_6
  }{
    \infere{T-Env1}{
      x : ?_6 \in \{f : ?_1, x : ?_5\}
    }{}
  }
\]
となります。規則 \textsc{T-Env1} により、$?_6 = ?_5$ という制約が追加されます。

これで、方程式の生成ができました。等式を列挙すると
\begin{itemize}
  \item $?_0 = ?_1 \to ?_2$
  \item $?_4 = ?_5 \to ?_6$
  \item $?_3 \to ?_2 = ?_1$
  \item $?_4 \to ?_3 = ?_1$
  \item $?_6 = ?_5$
\end{itemize}
となっています。

方程式を解いた結果は $?_n$ とその実体の対応という形になるとしましょう。

まず、上から3つ分の制約を解きます。等式をそのまま入れれば良いので、結果は
$\{?_0 = ?_1 \to ?_2, ?_1 = ?_3 \to ?_2, ?_4 = ?_5 \to ?_6\}$
のようになります。

次に、$?_4 \to ?_3 = ?_1$ を解きます。まず、$?_1$ は $?_3 \to ?_2$ と同じなので、
この制約は $?_4 \to ?_3 = ?_3 \to ?_2$ と等価です。
どちらも $?_n$ でないような形の制約は、構造を解いて複数の制約に変えることで適用します。
この場合は、 $?_4 = ?_3$ と $?_3 = ?_2$ に分解します。

$?_4 = ?_3$ と $?_3 = ?_2$ を適用すると、
$\{?_0 = ?_1 \to ?_2, ?_1 = ?_3 \to ?_2, ?_2 = ?_3, ?_3 = ?_4, ?_4 = ?_5 \to ?_6\}$
となります。

最後の $?_6 = ?_5$ を適用すると、
$\{?_0 = ?_1 \to ?_2, ?_1 = ?_3 \to ?_2, ?_2 = ?_3, ?_3 = ?_4, ?_4 = ?_5 \to ?_6, ?_5 = ?_6\}$
となります。これで方程式は全て解けました。

元々計算したかった型は $\emptyset \vdash \lambda f . f \, (f \, (\lambda x . x)) : ?_0$
となっているので、方程式の解の上で $?_0$ が何であるかを辿っていけば良いはずです。
これをやってみると、$(?_6 \to ?_6) \to ?_6 \to ?_6$ という型が得られます。

よって、型環境 $\emptyset$ の下で $\lambda f . f \, (f \, (\lambda x . x))$ は
$(\alpha \to \alpha) \to \alpha \to \alpha$ で型付けできるということが分かります。
また、他の型で型付け可能だとしても、それはこの型の $\alpha$ に対して別の型を代入した形を持ちます。

単純型付き $\lambda$ 計算の型推論は、このような方法で実現できます。
では、方程式の生成と制約解消系について、その詳細を順番に見ていきましょう。

\subsection{方程式の生成}

方程式の生成アルゴリズムを考えていきます。

まず、前提として今まで使ってきた $?_n$ のような
ユニークな型上の変数を無制限に作り出す仕組みがあると仮定しましょう。
また、この仕組みによって作られた型変数のことを\textbf{フレッシュな型変数}と呼びます。

方程式を生成する計算の名前を $\mathcal C$ としましょう\footnote{constraints の c から取りました。}。
この計算は、型環境 $\Gamma$ と項 $e$ を取り、方程式と項 $e$ の型を返すものとします。
また、項 $e$ の自由変数とその型は型環境 $\Gamma$ に含まれていなければならないものとします。

まず、$\mathcal C$ が型環境 $\Gamma$ と変数の項 $x$ を取る場合を考えます。
この場合は方程式は空で、型環境 $\Gamma$ から $x$ に対応する型を探して返します。

次に、$\mathcal C$ が型環境 $\Gamma$ と関数適用の項 $e_1 \, e_2$ を取る場合を考えます。
この場合はまず、$e_1$ と $e_2$ それぞれに関して計算 $\mathcal C$ に適用します。
適用した結果が $(c_1, t_1) = \mathcal{C}(\Gamma, e_1)$ と $(c_2, t_2) = \mathcal{C}(\Gamma, e_2)$
のようになるとします。

さて、$e_1 \, e_2$ の型は何になるでしょうか。
$t_1$ でも $t_2$ でもないことは明らかなので、フレッシュな型変数 $t_3$ を作り、これを結果としましょう。
$e_1 : t_1$ は $e_2 : t_2$ を引数に取り $e_1 \, e_2 : t_3$ を返すので、
この3つの型の間に $t_1 = t_2 \to t_3$ という等式が成り立つはずです。これが新しい制約です。
方程式全体は単純に足せば良いので、$c_1 \cup c_2 \cup \{t_1 = t_2 \to t_3\}$ と表せます。

次に、$\mathcal C$ が型環境 $\Gamma$ と $\lambda$ 抽象の項 $\lambda x . e$ を取る場合を考えます。
この場合はまず、フレッシュな型変数 $t_1$ を作り、
型環境 $\Gamma, x : t_1$ と項 $e$ に計算 $\mathcal C$ を適用します。
適用した結果が $(c, t_2) = \mathcal{C}(\Gamma, x : t_1, e)$ のようになるとします。
とくに追加する制約は無いので、結果の方程式は $c$、$\lambda x . e$ の型は $t_1 \to t_2$ となります。

以上をまとめると、方程式の生成アルゴリズム $\mathcal C$ は図\ref{fig:algorithm-c}のようになります。

\begin{figure}[htbp]
 \begin{align*}
  \mathcal{C}(\Gamma, x) &=
   \mathrm{if} ~ x \notin \mathit{dom}(\Gamma) ~
   \mathrm{then} ~ \mathit{failure} ~
   \mathrm{else} ~ (\emptyset, \Gamma(x)) \\
  \mathcal{C}(\Gamma, e_1 \, e_2) &=
  \begin{array}[t]{l}
   \mathrm{let}
    \begin{array}[t]{l}
     (c_1, t_1) = \mathcal{C}(\Gamma, e_1) \\
     (t_2, t_2) = \mathcal{C}(\Gamma, e_2) \\
     t_3 = \mathrm{flesh}
    \end{array} \\
   \mathrm{in} (c_1 \cup c_2 \cup \{t_1 = t_2 \to t_3\}, t_3)
  \end{array} \\
  \mathcal{C}(\Gamma, \lambda x . e) &=
  \begin{array}[t]{l}
   \mathrm{let}
    \begin{array}[t]{l}
     t_1 = \mathrm{flesh} \\
     (c, t_2) = \mathcal{C}((\Gamma, x : t_1), e)
    \end{array} \\
   \mathrm{in} (c, t_1 \to t_2)
  \end{array}
 \end{align*}
 \caption{方程式の生成アルゴリズム $\mathcal C$}
 \label{fig:algorithm-c}
\end{figure}

これは、
自由変数とその型は全て型環境に含まれているということの検査を含んでいるということに注意してください。
もしこの点が守られていなければ、$\mathit{failure}$ が返ります。
また、$\mathit{dom}(\Gamma)$ は型環境 $\Gamma$ の中の変数全ての集合を表します。
$\Gamma(x)$ というのは型環境 $\Gamma$ から $x$ の型を取ってくることを表します。
$\mathrm{flesh}$ はフレッシュな型変数を表します。

定数などを含む単純型付き $\lambda$ 計算に対しても、
同様の方法で対応するルールに沿うように制約の計算方法を追加することで正しい方程式の生成ができます。

このアルゴリズムによって生成される方程式を解くことで、単純型付き $\lambda$ 計算の型推論ができます。

\subsection{制約解消系}

次に、アルゴリズム $\mathcal C$ で生成した方程式を解くアルゴリズムについて考えます。

方程式を解く計算の名前を $\mathcal S$ としましょう\footnote{solve の s から取りました。}。
この計算は、制約集合を取り、型変数から実体への対応の集合を返すとしましょう。
また、今後はこの型変数から実体への対応の集合のことを、\textbf{代入 (substitutions)} と呼びます。

代入は、その対応関係を再帰的に辿っていっても必ずどこかで停止する、即ちループ構造を持たないとします。
つまり、この構造に関する帰納法が使えます。
また、そのような性質を破壊するような代入を作ってはいけません。

計算 $\mathcal S$ は、とある時点での代入と1つの制約を取り、
制約を適用した新しい代入を返す計算 $\mathcal{S'}$ による畳み込みによって実現できます。
そのような計算 $\mathcal{S'}$ のアルゴリズムについて考えていきましょう。

まず、$\mathcal{S'}$ が代入 $s$、等式 $t_1 \to t_2 = t_1' \to t_2'$ を取る場合を考えます。
これは、制約を $t_1 = t_1'$ と $t_2 = t_2'$ に分解して解きます。
つまり、$\mathcal{S'}(\mathcal{S'}(s, t_1 = t_1'), t_2 = t_2')$ が結果となります。

この $\to$ を分解するというのは、型を取って新しい型を構築する物全般に適用できます。
これは、Haskell の型コンストラクタのような物に対する規則であると考えられます。
型を構築しているものが一致しなければ、解が存在しないということになります。
例えば、$\mathrm{string} = \mathrm{int}$ のような等式はこれによって排除されます。

次に、$\mathcal{S'}$ が代入 $s$、等式 $\alpha = t_1$ もしくは $t_1 = \alpha$ を取る場合を考えます。
ただし、$\alpha$ は型変数を表します。
この場合は、もう少し詳細な場合分けをしなくてはいけません。

代入 $s$ に $\alpha$ の実体に関する情報が含まれている場合を考えます。
$\alpha$ の実体を $t_2$ とすると、$t_2 = t_1$ を解くことになります。

$t_1$ が $\alpha$ である場合を考えます。
等式が $\alpha = \alpha$ と等価なので、代入 $s$ がそのまま結果となります。

代入 $s$ に $\alpha$ の実体に関する情報が含まれず、$t_1$ が $\alpha$ ではない場合を考えます。
この場合は、代入 $s$ に $\alpha$ の実体が $t_1$ であるということを追加した代入が結果となるはずです。

仮に、ここで $t_1$ に $\alpha$ が含まれていたとしましょう。
これを代入に追加してしまえば、代入が満たすべき性質「ループ構造を持たない」が満たされなくなります。
この性質を守るための検査をする必要があります。
この検査の事を、\textbf{出現検査 (occurs check)} と呼びます。

出現検査は、$t_1$ の中に $\alpha$ が含まれていないかを調べ、
もし含まれていれば解無しという結果が返ります。
もし含まれていなければ、代入 $s \cup \{\alpha = t_1\}$ が結果となります。

以上をまとめると、方程式を解くアルゴリズム $\mathcal S$ は図\ref{fig:algorithm-s}のようになります。

\begin{figure}[htbp]
 \begin{align*}
  \mathcal{S'}(s, t_1 \to t_2 = t_1' \to t_2') &=
   \mathcal{S'}(\mathcal{S'}(s, t_1 = t_1'), t_2 = t_2') \\
  \mathcal{S'}(s, \alpha = t_1) &=
   \left \{
    \begin{array}{ll}
     \mathcal{S'}(s, s(\alpha) = t_1) & (\alpha \in \mathit{dom}(s)) \\
     s                                & (t_1 = \alpha) \\
     \textit{failure}                 & (\alpha \in \mathit{FTV}(t_1)) \\
     s \cup \{\alpha = t_1\}          & (\text{otherwise}) \\
    \end{array}
   \right .
%   \mathrm{if} ~ \alpha \in \mathit{dom}(s) ~
%   \mathrm{then} ~ \mathcal{S'}(s, s(\alpha) = t_1) ~
%   \mathrm{else} ~
   \\
  \mathcal{S'}(s, t_1 = \alpha) &= \mathcal{S'}(s, \alpha = t_1)
 \end{align*}
 \caption{方程式を解くアルゴリズム $\mathcal S$}
 \label{fig:algorithm-s}
\end{figure}



\section{実装}



