\documentclass[b5paper]{jsbook}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof}

\newlength{\lengthwithlength}
\newcommand{\bnfvert}{\settowidth{\lengthwithlength}{::=}\mathrel{\makebox[\lengthwithlength][c]{$|$}}}
\newcommand{\bnfcce}{\mathrel{::=}}

\title{Typing $\lambda^\to$}
\author{坂口和彦}

\begin{document}

\maketitle

\pagenumbering{roman}

\section*{前書き}

この本は、単純型付きラムダ計算からパラメトリック多相入りの型システム程度の範囲での型推論について、
体系的かつ理論と実装に一対一の対応が現れる形でまとめた本です。
最後まで読めば Hindley-Milner 型推論アルゴリズムの現実的な実装を理解できるということを目標としています。

型推論の実装は関数型プログラミング言語 Objective Caml (OCaml) 3.12.0
とその標準ライブラリによって記述されています。
読者は関数型プログラミングや OCaml のエキスパートである必要はありませんが、
ある程度 Haskell や OCaml での関数型言語らしいプログラムの書き方を理解していることを前提としています。

\tableofcontents
\newpage
\pagenumbering{arabic}

\chapter{$\lambda$ 計算入門}

$\lambda$ 計算は計算体系の一つで、計算を\textbf{関数}と\textbf{関数適用}で表します。
現在使われている多くの関数型プログラミング言語の基礎には、$\lambda$ 計算があると言えます。

次章から書く型推論の対象となる言語も、
最初は $\lambda$ 計算のシンプルな型システムとして知られる単純型付き $\lambda$ 計算です。

この章では、前提知識として必要な $\lambda$ 計算について説明します。

\section{$\lambda$ 計算}

$\lambda$ 計算では、関数を記号 $\lambda$ を使って表記します。
例えば、数値を取って1を足して返す関数は、
\[ \lambda x. x+1 \]
と表記します。

作った関数を値に適用する仕組みが必要です。
関数適用は、関数の式と引数の式を順番に並べて表記します。
例えば、引数をそのまま返す関数にその関数自身を適用するには、
\[ (\lambda x. x) (\lambda y. y) \] と表記します。

このような計算そのものを表現する物を項と呼びます。
$\lambda$ 計算の項は、図\ref{fig:lambda-term}のように帰納的に定義されます。

\begin{figure}[htbp]
  \begin{align*}
    e & \bnfcce  x             && \text{(変数)} \\
      & \bnfvert e ~ e         && \text{(関数適用)} \\
      & \bnfvert \lambda x . e && \text{($\lambda$ 抽象)}
  \end{align*}
  \caption{定義 : $\lambda$ 計算の項}
  \label{fig:lambda-term}
\end{figure}

このように、変数、巻数適用、$\lambda$ 抽象からなる物だけが $\lambda$ 計算の\textbf{項}と呼ばれます。
項のことを\textbf{式}という場合もあります。

また、図\ref{fig:lambda-term}の定義を見て分かる通り、
純粋な $\lambda$ 計算には整数値やブール値などの定数が存在しません。
しかし、整数値やブール値などを関数を使ってエンコードできることが知られています。
ここでは分かりやすいように適宜整数などを使うことがあります。

適切に構造を表現するために括弧を使って項を表記しますが、
表記を簡単にするために幾つかの省略のルールがあります。

$(e_1 e_2) e_3$ のような関数適用は $e_1 ~ e_2 ~ e_3$ と省略できます。
すなわち、関数適用の構文は左結合です。

$\lambda x. (e_1 e_2)$ のような $\lambda$ 抽象は $\lambda x. e_1 e_2$ と省略できます。
すなわち、関数適用の方が $\lambda$ 抽象に比べて優先されます。

\section{$\lambda$ 計算の実行}

$\lambda$ 計算の実行について考えてみましょう。

(まだ書いてない)

\section{型付き $\lambda$ 計算}

ここまでで説明した $\lambda$ 計算の上では、
停止しない計算(無限長の $\beta$ 簡約列を持つ項)を作れることが知られています。

例えば、$(\lambda x. x x) (\lambda x. x x)$ という項を簡約すると同じ形の項が出現するため、
無限長の $\beta$ 簡約列を作ることができます。

また、純粋な $\lambda$ 計算の範囲の話ではありませんが、
特定の種類の定数のみに対する演算を含む計算体系では
\[ (\lambda x . x + 1) { \it true } \]
のように途中で失敗する計算というのも考えられます。

このような、停止しない計算や失敗する計算を「正しくない計算」と見做し、正しくない計算を
表している項を排除する仕組みが\textbf{型付き $\lambda$ 計算 (typed lambda calculus)}です。
\footnote{
ただし、型付き $\lambda$ 計算から派生したプログラミング言語のほとんどは
プログラムが停止しないことや失敗することを許容しています。
しかし、その多くは型によってプログラムの間違いのほとんどを検出し、排除することに成功しています。}

型付き $\lambda$ 計算における\textbf{型 (type)} とは、とある項に対して適用可能な操作を表した物です。

\subsection{単純型付き $\lambda$ 計算}

\textbf{単純型付き $\lambda$ 計算 (simply typed lambda calculus, $\lambda^\to$)}は、
型付きラムダ計算の体系の1つです。

単純型付き $\lambda$ 計算の型は、図\ref{fig:stlc-type}のように帰納的に定義されます。

\begin{figure}[htbp]
  \begin{align*}
    t & \bnfcce  \alpha  && \text{(型変数)} \\
      & \bnfvert t \to t && \text{(関数の型)}
  \end{align*}
  \caption{定義 : 単純型付き $\lambda$ 計算の型}
  \label{fig:stlc-type}
\end{figure}

このように、型変数と関数の型だけからなるものを単純型付き $\lambda$ 計算の型とします。
型は同じ型変数を使うことで同じ型であることを表し、
$\alpha \to \beta$ は型 $\alpha$ の値から型 $\beta$ の値への関数を表します。

例えば、$\lambda x. x$ (恒等関数)は $\alpha \to \alpha$ という型を持ちます。

\subsection{型判定}

単純型付き $\lambda$ 計算では、
項に正しく型付けできるという事を\textgt{型判定 (type judgement)} で表します。

型環境 $\Gamma$ の下で項 $e$ の型が $t$ である、ということを
\[ \Gamma \vdash e : t \]
と書きます。

型環境 $\Gamma$ は、変数名と型のペアの集合($x_1 : t_1, x_2 : t_2, \dots, x_n : t_n$)です。
これは型を決定する上での文脈であり、変数の型はここから引いてくる事になります。

型環境 $\Gamma$ において変数 $x$ の型が $t$ である、という事を $x : t \in \Gamma$ と書きます。
また、この型環境 $\Gamma$ に「変数 $y$ の型が $t$ である」という事を追加した環境を作るとき、
$\Gamma , y : t$ と書きます。これらは、図\ref{fig:stlc-type-environment}のように定義されます。

\begin{figure}[htbp]
  \[
    \infer[\textsc{[T-Env1]}]{
      x : t \in \Gamma , x : t
    }{}
  \]
  \[
    \infer[\textsc{[T-Env2]}]{
      x : t_1 \in \Gamma , y : t_2
    }{
      x \neq y && x : t_1 \in \Gamma
    }
  \]
  \caption{定義 : 型環境}
  \label{fig:stlc-type-environment}
\end{figure}

\textsc{T-Env1} や \textsc{T-Env2} のような規則は、上が仮定で下が結論になっています。

規則 \textsc{T-Env1} は型環境 $\Gamma , x : t$ において変数 $x$ の型は $t$ である、と読みます。
規則 \textsc{T-Env2} は型環境 $\Gamma$ において変数 $x$ の型が $t_1$ かつ $x \neq y$ であれば、
型環境 $\Gamma , y : t_2$ において変数 $x$ の型が $t_1$ である、と読みます。

型判定の事を型環境、項、型の間の関係とみなし、
\textgt{型付け関係 (typing relation)} と呼ぶ事もあります。

単純型付き $\lambda$ 計算の型判定は、図\ref{fig:stlc-type-judgement}のようなルールで表せます。
このルールは、$\lambda$ 計算の項の種類1つに対してルールが1つであるということに注意してください。

\begin{figure}[htbp]
  \[
    \infer[\textsc{[T-Var]}]{
      \Gamma \vdash x : t
    }{
      x : t \in \Gamma
    }
  \]
  \[
    \infer[\textsc{[T-App]}]{
      \Gamma \vdash e_1 ~ e_2 : t_2
    }{
      \Gamma \vdash e_1 : t_1 \to t_2 &
      \Gamma \vdash e_2 : t_1
    }
  \]
  \[
    \infer[\textsc{[T-Abs]}]{
      \Gamma \vdash \lambda x . e : t_1 \to t_2
    }
    {
      \Gamma, x : t_1 \vdash e : t_2
    }
  \]
  \caption{定義 : 単純型付き $\lambda$ 計算の型判定}
  \label{fig:stlc-type-judgement}
\end{figure}

これらは、図\ref{fig:stlc-type-environment}の定義と同様に、上が仮定で下が結論となっています。

規則 \textsc{T-Var} は変数に関する規則です。
型環境 $\Gamma$ において変数 $x$ の型が $t$ であれば、
型環境 $\Gamma$ の下で式 $x$ の型は $t$ である、と読みます。

規則 \textsc{T-App} は関数適用に関する規則です。
型環境 $\Gamma$ の下で式 $e_1$ の型が $t_1 \to t_2$ かつ $e_2$ の型が $t_1$ であれば、
型環境 $\Gamma$ の下で式 $e_1 ~ e_2$ の型は $t_2$ である、と読みます。

規則 \textsc{T-Abs} は $\lambda$ 抽象に関する規則です。
型環境 $\Gamma , x : t_1$ の下で式 $e$ の型が $t_2$ であれば、
型環境 $\Gamma$ の下で式 $\lambda x . e$ の型は $t_1 \to t_2$ である、と読みます。

最初は難しく感じるかもしれませんが、慣れるとこのように書いた方が分かりやすくなるでしょう。



\end{document}

