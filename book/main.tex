\documentclass[b5paper]{jsbook}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{theorem}
\usepackage{proof}

\newlength{\lengthwithlength}
\newcommand{\bnfvert}{\settowidth{\lengthwithlength}{::=}\mathrel{\makebox[\lengthwithlength][c]{$|$}}}
\newcommand{\bnfcce}{\mathrel{::=}}

\newcommand{\betared}{\to_\beta}

\newtheorem{exercise}{練習問題}[chapter]
\newtheorem{answer}{回答}[chapter]

\title{Typing $\lambda^\to$}
\author{坂口和彦}

\begin{document}

%\maketitle

\pagenumbering{roman}

\section*{前書き}

この本は、単純型付きラムダ計算からパラメトリック多相入りの型システム程度の範囲での型推論について、
体系的かつ理論と実装に一対一の対応が現れる形でまとめた本です。
最後まで読めば Hindley-Milner 型推論アルゴリズムの現実的な実装を理解できるということを目標としています。

型推論の実装は関数型プログラミング言語 Objective Caml (OCaml) 3.12.0
とその標準ライブラリによって記述されています。
読者は関数型プログラミングや OCaml のエキスパートである必要はありませんが、
ある程度 Haskell や OCaml での関数型言語らしいプログラムの書き方を理解していることを前提としています。

\tableofcontents

\newpage

\pagenumbering{arabic}

\chapter{$\lambda$ 計算入門}

$\lambda$ 計算は計算体系の一つで、計算を\textbf{関数}と\textbf{関数適用}で表します。
現在使われている多くの関数型プログラミング言語の基礎には、$\lambda$ 計算があると言えます。

次章から書く型推論の対象となる言語も、
最初は $\lambda$ 計算のシンプルな型システムとして知られる単純型付き $\lambda$ 計算です。

この章では、前提知識として必要な $\lambda$ 計算と単純型付き $\lambda$ 計算について説明します。

\section{$\lambda$ 計算}

$\lambda$ 計算では、関数を記号 $\lambda$ を使って
$\lambda \text{パラメータ名} . \text{結果}$ と表記します。
例えば、数値を取って1を足して返す関数は、
\[ \lambda x. x+1 \]
と表記します\footnote{本来の $\lambda$ 計算には数値や加算は含まれませんが、
分かりやすいように適宜このような表記を使います。}。

作った関数を値に適用する仕組みが必要です。関数適用は、関数と引数を順番に並べて表記します。
例えば、引数をそのまま返す関数にその関数自身を適用するには、
\[ (\lambda x. x) (\lambda y. y) \]
と表記します。

このような計算そのものを表現する物を項と呼びます。
$\lambda$ 計算の項は、図\ref{fig:lambda-term}のように帰納的に定義されます。

\begin{figure}[htbp]
  \begin{align*}
    e & \bnfcce  x             && \text{(変数)} \\
      & \bnfvert e ~ e         && \text{(関数適用)} \\
      & \bnfvert \lambda x . e && \text{($\lambda$ 抽象)}
  \end{align*}
  \caption{定義 : $\lambda$ 計算の項}
  \label{fig:lambda-term}
\end{figure}

変数、巻数適用、$\lambda$ 抽象からなる物だけが $\lambda$ 計算の\textbf{項 (term)}と呼ばれます。
項のことを\textbf{式 (expression)}という場合もあります。

また、図\ref{fig:lambda-term}の定義を見て分かる通り、
純粋な $\lambda$ 計算には整数値やブール値などの定数が存在しません。
しかし、整数値やブール値などを関数を使ってエンコードできることが知られています。
ここでは分かりやすいように適宜整数などを使うことがあります。

適切に構造を表現するために括弧を使って項を表記しますが、
表記を簡単にするために幾つかの省略のルールがあります。

$(e_1 e_2) e_3$ のような関数適用は $e_1 ~ e_2 ~ e_3$ と省略できます。
すなわち、関数適用の構文は左結合です。

$\lambda x. (e_1 e_2)$ のような $\lambda$ 抽象は $\lambda x. e_1 e_2$ と省略できます。
すなわち、関数適用の方が $\lambda$ 抽象に比べて優先されます。

\begin{exercise}

次のうち、$\lambda$ 計算の項として正しくない物はどれか。

\begin{enumerate}
  \item $\lambda x . x$
  \item $\lambda f . f x$
  \item $f (\lambda x)$
\end{enumerate}

1番目は、$x$ が変数として正しく、
$\lambda x . x$ 全体も $\lambda$ 抽象として正しいので正しい項になっています。

2番目は、$f$ と $x$ がそれぞれ変数として正しく、$f x$ が関数適用として正しく、
$\lambda f . f x$ 全体も $\lambda$ 抽象として正しいので正しい項になっています。

3番目は、$f$ と $x$ はそれぞれ変数として正しい形になっていますが、
$\lambda x$ は正しい $\lambda$ 計算の項の形をしていません。
よって、$f (\lambda x)$ 全体も正しい $\lambda$ 計算の項ではありません。

$\lambda$ 計算の項として正しくない物は、三番目の $f (\lambda x)$ です。

\end{exercise}

\begin{exercise}

以下の $\lambda$ 計算の項を実行した結果は何になるか、答えよ。

\begin{enumerate}
  \item $(\lambda x . x) (\lambda y . y)$
  \item $(\lambda f . \lambda g . \lambda x . f x (g x))
		(\lambda x . \lambda y . x) (\lambda x . \lambda y . x)$
\end{enumerate}

1番目は、外側の関数適用を実行すると $\lambda y . y$ となります。よって、実行結果は $\lambda y . y$
となります。

2番目は、まず項 $(\lambda f . \lambda g . \lambda x . f x (g x)) (\lambda x . \lambda y . x)$
の関数適用を実行します。結果は、$\lambda g . \lambda x . (\lambda x . \lambda y . x) x (g x)$
となり、これの内側の2つの関数適用を実行すると $\lambda g . \lambda x . x$ となります。
よって、項全体は $(\lambda g . \lambda x . x) (\lambda x . \lambda y . x)$ となります。
この項の外側の関数適用を実行すると、$\lambda x . x$ となります。
実行結果は $x . x$ です。

\end{exercise}

\section{$\lambda$ 計算の実行}

$\lambda$ 計算の実行について考えてみましょう。

前の練習問題で分かる通り、$\lambda$ 計算の実行の本質は、左辺が $\lambda$ 抽象になっている関数適用
($(\lambda x . e_1) e_2$ の形をしている $\lambda$ 項)を解く操作です。
この操作は、項 $e_1$ の中の自由変数 $x$ を全て項 $e_2$ で置き換える操作です。
この自由変数を全て置き換える操作を\textbf{代入}と呼び、$[e_2/x] e_1$ と表記します。

図 \ref{fig:lambda-substitute} に代入の定義を示します。

\begin{figure}[htbp]
  \begin{align*}
    [y/x] e_1 & = \left \{
      \begin{array}{ll}
        e_1 & (x = y) \\
        y & (x \neq y)
      \end{array}
      \right. \\
    [e_2 ~ e_3/x] e_1 & = ([e_2/x] e_1) ([e_3/x] e_1) \\
    [\lambda y . e_2/x] e_1 & = \left \{
      \begin{array}{ll}
        \lambda y . [e_2/x] e_1 & (x \neq y) \\
        \lambda y . e_2 & (x = y)
      \end{array}
      \right.
  \end{align*}
  \caption{定義 : 代入}
  \label{fig:lambda-substitute}
\end{figure}

次に、代入を使って $\lambda$ 計算の項の関数適用を評価するを作りましょう。

項の中の関数適用を一度実行する事を、\textbf{$\beta$簡約 ($\beta$-retuction)}と呼びます。
$e_1$ を $\beta$ 簡約して $e_2$ にできるという事を、$e_1 \betared e_2$ と表記します。
図 \ref{fig:beta-reduction} に $\beta$ 簡約の定義を示します。

\begin{figure}[htbp]
  \[
    \infer[\textsc{[R-Beta]}]{
      (\lambda x . e_1) e_2 \betared [e_2/x]e_1
    }{}
  \]
  \[
    \infer[\textsc{[R-App1]}]{
      e_1 ~ e_2 \betared e_1' ~ e_2
    }{
      e_1 \betared e_1'
    }
  \]
  \[
    \infer[\textsc{[R-App2]}]{
      e_1 ~ e_2 \betared e_1 ~ e_2'
    }{
      e_2 \betared e_2'
    }
  \]
  \[
    \infer[\textsc{[R-Abs]}]{
      \lambda x . e \betared \lambda x . e'
    }{
      e \betared e'
    }
  \]
  \caption{定義 : $\beta$ 簡約}
  \label{fig:beta-reduction}
\end{figure}

この分数のような表記は、上が仮定で下が結論であるような規則を表しています。
つまり、上に書いてある事が成り立てば、下に書いてある事を成り立つとして良いという事になります。

規則の右側に書いてある \textsc{R-Beta}, \textsc{R-App1}, \textsc{R-App2}, \textsc{R-Abs}
は規則の名前を表しています。

また、\textsc{R-Beta} 規則のように上が空である場合は、
無条件で下に書いてある事を認めて良いという事を表しています。

$\lambda$ 項の評価は $\beta$ 簡約の並びによって表現できます。

\begin{exercise}

以下の $\beta$ 簡約ができる事を示せ。

\[
  (\lambda x . x) ~ f ~ y \betared f ~ y
\]

これは、$(\lambda x . x) ~ f$ の部分を簡約すれば良さそうです。$[f/x] x = f$ なので、
\[
  \infer[\textsc{[R-Beta]}]{
    (\lambda x . x) ~ f \betared f
  }{}
\]
とできます。この部分式は全体から見ると関数適用の左辺なので、
\[
  \infer[\textsc{[R-App1]}]{
    (\lambda x . x) ~ f ~ y \betared f ~ y
  }{
    (\lambda x . x) ~ f \betared f
  }
\]
とできます。
このようにして、$(\lambda x . x) ~ f ~ y \betared f ~ y$ が正しい $\beta$ 簡約である事が示せます。

また、実際はこの2つの証明の段階を繋げて、
\[
  \infer[\textsc{[R-App1]}]{
    (\lambda x . x) ~ f ~ y \betared f ~ y
  }{
    \infer[\textsc{[R-Beta]}]{
      (\lambda x . x) ~ f \betared f
    }{}
  }
\]
のように表記します。
これによって、複雑な構造を持つ証明を分かりやすく記述する事ができます。

\end{exercise}

\begin{exercise}

以下の $\lambda$ 項を簡約せよ。

\[
  (\lambda x . x ~ x) (\lambda x . x ~ x)
\]

外側の関数適用が簡約できます。
$[(\lambda x . x ~ x)/x]x ~ x = (\lambda x . x ~ x) (\lambda x . x ~ x)$ なので、
\[
  \infer[\textsc{[R-Beta]}]{
    (\lambda x . x ~ x) (\lambda x . x ~ x) \betared (\lambda x . x ~ x) (\lambda x . x ~ x)
  }{}
\]
となります。

しかし、簡約した結果として自分自身と同じ項が作れてしまいました。
この事から、この項は無限長の $\beta$ 簡約列を作る事ができ、評価が停止しないと分かります。

この例以外にも、無限長の $\beta$ 簡約列を作れる $\lambda$ 項は無数に存在しています。

\end{exercise}

\section{型付き $\lambda$ 計算}

前の練習問題のように、無限長の $\beta$ 簡約列を作る事ができるような $\lambda$ 項を作る事ができます。

また、純粋な $\lambda$ 計算の範囲の話ではありませんが、定数値や定数値に対する演算を含む計算体系では、
特定の種類の定数値のみを対象とできる演算を考えたい場合があります。例えば、
\[
  { \it true } + 1
\]
は加算が数値に対する二項演算であって欲しいとすると、
ブール値 $\it true$ と整数値 $1$ に対して適用されているため意図に反した計算であると言えます。

このような、停止しない計算や意図に反する計算を「正しくない計算」と見做し、正しくない計算を
表している項を排除する仕組みが\textbf{型付き $\lambda$ 計算 (typed lambda calculus)}です。
\footnote{
ただし、型付き $\lambda$ 計算から派生したプログラミング言語のほとんどは
プログラムが停止しないことや失敗することを許容しています。
しかし、その多くは型によってプログラムの間違いのほとんどを検出し、排除することに成功しています。}

型付き $\lambda$ 計算における\textbf{型 (type)} とは、とある項に対して適用可能な操作を表した物です。

\subsection{単純型付き $\lambda$ 計算}

\textbf{単純型付き $\lambda$ 計算 (simply typed lambda calculus, $\lambda^\to$)}は、
型付きラムダ計算の体系の1つです。

単純型付き $\lambda$ 計算の型は、図\ref{fig:stlc-type}のように帰納的に定義されます。

\begin{figure}[htbp]
  \begin{align*}
    t & \bnfcce  \alpha  && \text{(型変数)} \\
      & \bnfvert t \to t && \text{(関数の型)}
  \end{align*}
  \caption{定義 : 単純型付き $\lambda$ 計算の型}
  \label{fig:stlc-type}
\end{figure}

このように、型変数と関数の型だけからなるものを単純型付き $\lambda$ 計算の型とします。
型は同じ型変数を使うことで同じ型であることを表し、
$\alpha \to \beta$ は型 $\alpha$ の値から型 $\beta$ の値への関数を表します。

例えば、$\lambda x. x$ (恒等関数)は $\alpha \to \alpha$ という型を持ちます。

\subsection{型判定}

単純型付き $\lambda$ 計算では、
項に正しく型付けできるという事を\textbf{型判定 (type judgement)} で表します。

型環境 $\Gamma$ の下で項 $e$ の型が $t$ である、ということを
\[ \Gamma \vdash e : t \]
と表記します。

型環境 $\Gamma$ は、変数名と型のペアの集合($x_1 : t_1, x_2 : t_2, \dots, x_n : t_n$)です。
これは型を決定する上での文脈であり、変数の型はここから引いてくる事になります。

型環境 $\Gamma$ において変数 $x$ の型が $t$ である、という事を $x : t \in \Gamma$ と表記します。
また、この型環境 $\Gamma$ に「変数 $y$ の型が $t$ である」という事を追加した環境を作るとき、
$\Gamma , y : t$ と表記します。これらは、図\ref{fig:stlc-type-environment}のように定義されます。

\begin{figure}[htbp]
  \[
    \infer[\textsc{[T-Env1]}]{
      x : t \in \Gamma , x : t
    }{}
  \]
  \[
    \infer[\textsc{[T-Env2]}]{
      x : t_1 \in \Gamma , y : t_2
    }{
      x \neq y && x : t_1 \in \Gamma
    }
  \]
  \caption{定義 : 型環境}
  \label{fig:stlc-type-environment}
\end{figure}

型判定の事を型環境、項、型の間の関係とみなし、
\textbf{型付け関係 (typing relation)} と呼ぶ事もあります。

単純型付き $\lambda$ 計算の型判定は、図\ref{fig:stlc-type-judgement}のようなルールで表せます。
このルールは、$\lambda$ 計算の項の種類1つに対してルールが1つであるということに注意してください。

\begin{figure}[htbp]
  \[
    \infer[\textsc{[T-Var]}]{
      \Gamma \vdash x : t
    }{
      x : t \in \Gamma
    }
  \]
  \[
    \infer[\textsc{[T-App]}]{
      \Gamma \vdash e_1 ~ e_2 : t_2
    }{
      \Gamma \vdash e_1 : t_1 \to t_2 &
      \Gamma \vdash e_2 : t_1
    }
  \]
  \[
    \infer[\textsc{[T-Abs]}]{
      \Gamma \vdash \lambda x . e : t_1 \to t_2
    }
    {
      \Gamma, x : t_1 \vdash e : t_2
    }
  \]
  \caption{定義 : 単純型付き $\lambda$ 計算の型判定}
  \label{fig:stlc-type-judgement}
\end{figure}



\end{document}

