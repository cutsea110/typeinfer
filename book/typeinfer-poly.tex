
この章では、単純型付き $\lambda$ 計算に一階の多相型を追加した体系の型推論について論じます。

\section{多相の必要性}

単純型付き $\lambda$ 計算に整数値と整数型とタプル(組)の型を追加した体系では、
$(\lambda x. x) \, 12, (\lambda x . x) \, (\lambda x . x)$
という項は $\mathrm{int} \times (\alpha \to \alpha)$ という型で型付けできます。
\footnote{$e_1, e_2$ は $e_1$ と $e_2$ の組の項を表します。
$t_1 \times t_2$ は $t_1$ 型の値と $t_2$ 型の値の組の型を表します。}

しかし、この項の中の恒等関数を括り出して $(\lambda f .(f \, 12, f \, f)) \, (\lambda x . x)$
のように書き換えてやると、型付けできなくなってしまいます。
これは、恒等関数の型が元々
$\mathrm{int} \to \mathrm{int}$ と $(\alpha \to \alpha) \to \alpha \to \alpha$ と
$\alpha \to \alpha$ のように全て一致しないことによる問題です。

これらの型はどれも $t_1 \to t_1$ の形を持っていますが、
それぞれ $t_1$ に入る型が違ってしまうために型が合いません。
これでは任意の型に関する関数などが書けず、そのために同じ定義を何度も書かなければなりません。

この章で扱う多相は、この「任意の型」を扱うための多相です。
この多相性を追加した型付き $\lambda$ 計算について考えてみましょう。

\section{let 項}

前節で説明したような多相性を導入することを明示するための新しい項の要素を、
$\lambda$ 項の定義に追加します。

この新しい項の要素を\textbf{let 項 (let term)} と呼び、
$(\letterm{x}{e_1}{e_2})$ のように表記します。

この項の簡約の上での意味は $(\lambda x . e_2) \, e_1$ と同一であり、
$e_1$ が多相的に変数 $x$ に束縛されるものとします。

let 項を追加した項を、図\ref{fig:poly-lambda-term}のように定義します。

\begin{figure}[htbp]
  \begin{align*}
    e & \bnfcce  x                   && \text{(変数)} \\
      & \bnfvert (e \, e)            && \text{(関数適用)} \\
      & \bnfvert (\lambda x . e)     && \text{($\lambda$ 抽象)} \\
      & \bnfvert (\letterm{x}{e}{e}) && \text{(let 項)}
  \end{align*}
  \caption{$\lambda$ 計算の項に let を追加した項}
  \label{fig:poly-lambda-term}
\end{figure}

省略に関する追加の規則は以下の通りです。

\begin{enumerate}
  \item 項 $e$ の部分項 $(\letterm{x}{e_1}{e_2})$ は、$e_2$ の左右に対応する括弧があれば、
        その括弧を省略できます。
\end{enumerate}

\begin{note}
ここまでの内容で、省略表記であることが明らかでない let 項の表記は省略されていてはならない。
\end{note}

\section{置換による多相}

\subsection{アルゴリズム}

この節では、多相性を含む新しい項の定義に対する最も簡単な型付けの体系と、
その体系に合った適切な型推論アルゴリズムを定義します。

多相を導入する項、即ち let 項を全て簡約してしまえば、
多相性がどこにも現れない実行の意味で等価な項が得られるはずです。

let を含む任意の項から、その項中の let 項を全て簡約した項を計算するアルゴリズムが存在します。
このアルゴリズムの名前を $\mathcal R_\mathrm{let}$ とします。

アルゴリズム $\mathcal R_\mathrm{let}$ は図\ref{fig:algorithm-rlet}のように定義できます。

\begin{figure}[htbp]
  \begin{align*}
    \mathcal R_\mathrm{let}(x) &= x \\
    \mathcal R_\mathrm{let}(e_1 e_2) &=
      \mathcal R_\mathrm{let}(e_1) \, \mathcal R_\mathrm{let}(e_2) \\
    \mathcal R_\mathrm{let}(\lambda x . e) &=
      \lambda x . \mathcal R_\mathrm{let}(e) \\
    \mathcal R_\mathrm{let}(\letterm{x}{e_1}{e_2}) &=
      \mathcal R_\mathrm{let}(e_2 [x := \mathcal R_\mathrm{let}(e_1)])
  \end{align*}
  \caption{アルゴリズム $\mathcal R_\mathrm{let}$}
  \label{fig:algorithm-rlet}
\end{figure}

このアルゴリズムは再帰に関して項の構造もしくは項中の let 項の数が減少しているため、
正しい帰納的定義になっています。

これによって let を含む項を let を含まない等価な項に変換し、
2章で示したアルゴリズムによって型推論をすることで、let を含む項の型を推論できます。

ただし、簡約をしてしまうと変数の捕獲が問題になってしまう場合があります。
適切な $\alpha$ 変換をするアルゴリズムを書いても良いのですが、
制約を生成するアルゴリズムに少し変更を加えることによって、
より実装に向いた型推論アルゴリズムを得られます。

let を含む項の場合では、導入される変数が二種類あります。
一方は単相的に束縛され、もう一方は多相的に束縛されます。

制約の生成の上でこれらを区別するようにしましょう。
単相の変数は型だけを持っておけば良いはずです。一方、多相の変数は型環境と項を持っておき、
変数が使われる度に制約を生成することで適切な制約集合が得られます。
これらを区別するため、前者は持つ型を $t$ としたときに $\mathrm{Mono}(t)$ と、
後者は型環境と項をそれぞれ $\Gamma$ と $e$ としたときに $\mathrm{Poly}(\Gamma, e)$ と表記します。

let を含む項に対する制約生成アルゴリズム $\mathcal{C}_P$ を、
図\ref{fig:algorithm-cp}のように定義します。

\begin{figure}[htbp]
  \begin{align*}
    \mathcal{C}_P(\Gamma, x) &=
      \begin{cases}
        \mathit{failure}          & (x \notin \mathit{dom}(\Gamma)) \\
        t                         & (\mathrm{Mono}(t) = \Gamma(x)) \\
        \mathcal{C}_P(\Gamma', e) & (\mathrm{Poly}(\Gamma', e) = \Gamma(x)) \\
      \end{cases} \\
    \mathcal{C}_P(\Gamma, e_1 \, e_2) &=
      \begin{array}[t]{l}
        \mathrm{let}
          \begin{array}[t]{l}
            (c_1, t_1) = \mathcal{C}_P(\Gamma, e_1) \\
            (t_2, t_2) = \mathcal{C}_P(\Gamma, e_2) \\
            t_3 = \mathrm{fresh}
          \end{array} \\
        \mathrm{in} (c_1 \cup c_2 \cup \{t_1 = t_2 \to t_3\}, t_3)
      \end{array} \\
    \mathcal{C}_P(\Gamma, \lambda x . e) &=
      \begin{array}[t]{l}
        \mathrm{let}
          \begin{array}[t]{l}
            t_1 = \mathrm{fresh} \\
            (c, t_2) = \mathcal{C}_P((\Gamma, x : \mathrm{Mono}(t_1)), e)
          \end{array} \\
        \mathrm{in} (c, t_1 \to t_2)
      \end{array} \\
    \mathcal{C}_P(\Gamma, \letterm{x}{e_1}{e_2}) &=
      \mathcal{C}_P((\Gamma, x : \mathrm{Poly}(\Gamma, e_1)), e_2)
  \end{align*}
  \caption{方程式の生成アルゴリズム $\mathcal C_P$}
  \label{fig:algorithm-cp}
\end{figure}



\subsection{実装}



\begin{lstlisting}
type assump_elem
    = Monovar of ty
    | Polyvar of (assump_elem String.Map.t * term)
type assump = assump_elem String.Map.t
\end{lstlisting}



\begin{lstlisting}
let rec constraints (n : int) (env : assump) :
    term -> (int * tconst list * ty) option =
  function
    | EVar str ->
      begin match String.Map.find env str with
        | Some (Monovar t) -> Some (n, [], t)
        | Some (Polyvar (env', term)) -> constraints n env' term
        | None -> None
      end
    | EApp (term1, term2) ->
      begin match constraints (succ n) env term1 with
        | Some (n1, c1, t1) ->
          begin match constraints n1 env term2 with
            | Some (n2, c2, t2) ->
              let tn = TVar n in
              Some (n2, (t1, TFun (t2, tn)) :: c1 @ c2, tn)
            | None -> None
          end
        | None -> None
      end
    | EAbs (ident, term) ->
      begin
        let tn = TVar n in
        let newenv = String.Map.add ident (Monovar tn) env in
        match constraints (succ n) newenv term with
          | Some (n', c, t) -> Some (n', c, TFun (tn, t))
          | None -> None
      end
    | ELet (ident, term1, term2) ->
      let newenv = String.Map.add ident (Polyvar (env, term1)) env in
      constraints n newenv term2
\end{lstlisting}



\section{パラメトリック多相}



\subsection{アルゴリズム}



\subsection{実装}



\section{まとめ}



