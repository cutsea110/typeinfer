
この章では、単純型付き $\lambda$ 計算に多相性を追加した体系の型推論について論じます。

\section{多相の必要性}

$(\lambda x. x) \, 12, (\lambda x . x) \, (\lambda x . x)$ という項の型を考えてみましょう。

ここで、$(e_1, e_2)$ という形で表わされている部分は $e_1$ と $e_2$ の直積(タプル)です。
型 $\tau_1$ と型 $\tau_2$ の直積型を $(\tau_1 \times \tau_2)$ という形で表現します。
直積に関する追加の型付け規則 \textsc{T-Pro} を、図\ref{fig:product-type-judgement}のように定義します。

\begin{figure}[htbp]
  \[
    \infere{T-Pro}{
      \Gamma \vdash (e_1, e_2) : (\tau_1 \times \tau_2)
    }{
      \Gamma \vdash e_1 : \tau_1 &
      \Gamma \vdash e_2 : \tau_2
    }
  \]
  \caption{直積に関する型判定}
  \label{fig:product-type-judgement}
\end{figure}

今考えている項は、整数値の型を $\mathrm{int}$ とすると
$\mathrm{int} \times (\alpha \to \alpha)$ という型で型付けできます。

しかし、この項の中の恒等関数を括り出して $(\lambda f .(f \, 12, f \, f)) \, (\lambda x . x)$
のように書き換えてやると、型付けできなくなってしまいます。
これは、恒等関数の型が元々
$\mathrm{int} \to \mathrm{int}$ と $(\alpha \to \alpha) \to \alpha \to \alpha$ と
$\alpha \to \alpha$ のように全て一致しないことによる問題です。

これらの型はどれも $\tau_1 \to \tau_1$ の形を持っていますが、
それぞれ $\tau_1$ に入る型が違ってしまうために型が合いません。
これでは任意の型に関する関数などが書けず、そのために同じ定義を何度も書かなければなりません。

この章で扱う多相は、この「任意の型」を扱うための多相です。
この多相性を追加した型付き $\lambda$ 計算について考えてみましょう。

\section{let 項}

前節で説明したような多相性を導入することを明示するための新しい項の要素を、
$\lambda$ 項の定義に追加します。

この新しい項の要素を\textbf{let 項 (let term)} と呼び、
$(\letterm{x}{e_1}{e_2})$ のように表記します。
また、この新しく定義される項全体を $\lambda^\mathrm{let}$ 項と呼びます。

$\lambda^{let}$ 項を、図\ref{fig:poly-lambda-term}のように定義します。

\begin{figure}[htbp]
  \begin{align*}
    e & \bnfcce  x                   && \text{(変数)} \\
      & \bnfvert (e \, e)            && \text{(関数適用)} \\
      & \bnfvert (\lambda x . e)     && \text{($\lambda$ 抽象)} \\
      & \bnfvert (\letterm{x}{e}{e}) && \text{(let 項)}
  \end{align*}
  \caption{$\lambda^\mathrm{let}$ 項}
  \label{fig:poly-lambda-term}
\end{figure}

let 項 $(\letterm{x}{e_1}{e_2})$ の簡約の上での意味は $(\lambda x . e_2) \, e_1$ と同一であり、
変数 $x$ が項 $e_1$ に多相的に束縛されるものとします。

$\lambda$ 抽象で束縛されている変数を単相的な変数、let 項で束縛されている変数を多相的な変数と呼びます。

省略に関する追加の規則は以下の通りです。

\begin{enumerate}
  \item 項 $e$ の部分項 $(\letterm{x}{e_1}{e_2})$ は、$e_2$ の左右に対応する括弧があれば、
        その括弧を省略できます。
\end{enumerate}

\begin{note}
ここまでの内容で、省略表記であることが明らかでない let 項の表記は省略されていてはならない。
\end{note}

このような体系を考えることにより、前節で出てきた $(\lambda f .(f \, 12, f \, f)) \, (\lambda x . x)$
という項は、$\letterm{x}{\lambda x . x}{f \, 12, f \, f}$ に書き換えられます。
適切な型付けの体系を与えることで、この項を型付けすることができるようになります。

\section{置換による多相}

\subsection{アルゴリズム}

この節では、$\lambda^\mathrm{let}$ 項に対する最も簡単な型付けの体系と、
その体系に合った適切な型推論アルゴリズムを定義します。

多相を導入する項、即ち let 項を全て簡約してしまえば、
多相性がどこにも現れない値として同値な項が得られるはずです。

let を含む任意の項から、その項中の let 項を全て簡約した項を計算するアルゴリズムが存在します。
このアルゴリズムの名前を $\mathcal R^\mathrm{let}$ とします。

アルゴリズム $\mathcal R^\mathrm{let}$ は図\ref{fig:algorithm-rlet}のように定義できます。

\begin{figure}[htbp]
  \begin{align*}
    \mathcal R^\mathrm{let}(x) &= x \\
    \mathcal R^\mathrm{let}(e_1 e_2) &=
      \mathcal R^\mathrm{let}(e_1) \, \mathcal R^\mathrm{let}(e_2) \\
    \mathcal R^\mathrm{let}(\lambda x . e) &=
      \lambda x . \mathcal R^\mathrm{let}(e) \\
    \mathcal R^\mathrm{let}(\letterm{x}{e_1}{e_2}) &=
      \mathcal R^\mathrm{let}(e_2 [x := \mathcal R^\mathrm{let}(e_1)])
  \end{align*}
  \caption{アルゴリズム $\mathcal R^\mathrm{let}$}
  \label{fig:algorithm-rlet}
\end{figure}

このアルゴリズムは再帰に関して項中の let 項の出現数もしくは項の構造が減少し、
かつ項中の let 項の出現数が増加することは無いため、
項中の let 項の出現数と項の構造の辞書式順序の帰納法を使った正しい帰納的定義になっています。

これによって $\lambda^\mathrm{let}$ 項を $\lambda$ 項に変換し、
2章で示したアルゴリズムによって型推論をすることで、let を含む項の型を推論できます。

ただし、簡約をしてしまうと変数の捕獲が問題になってしまう場合があります。
適切な $\alpha$ 変換をするアルゴリズムを書いても良いのですが、
制約を生成するアルゴリズムに少し変更を加えることによって、
より実装に向いた型推論アルゴリズムを得られます。

$\lambda^\mathrm{let}$ 項には、単相的に束縛される変数と多相的に束縛される変数があります。

型環境の上でこれらを区別するようにしましょう。
単相の変数は型だけを持っておけば良いはずです。一方、多相の変数は型環境と項を持っておき、
変数が使われる度に制約を生成することで適切な制約集合が得られます。
これらを区別するため、前者は持つ型を $\tau$ としたときに $\mathrm{Mono}(\tau)$ と、
後者は型環境と項をそれぞれ $\Gamma$ と $e$ としたときに $\mathrm{Poly}(\Gamma, e)$ と表記します。
\footnote{それぞれ、monomorphic (単相的)と polymorphic (多相的)の略。}

$\lambda^\mathrm{let}$ 項に対する制約生成アルゴリズム $\mathcal C^\mathrm{let}$ を、
図\ref{fig:algorithm-cp}のように定義します。

\begin{figure}[htbp]
  \begin{align*}
    \mathcal C^\mathrm{let}(\Gamma, x) &=
      \begin{cases}
        \mathit{failure}                    & (x \notin \mathit{dom}(\Gamma)) \\
        \tau                                & (\mathrm{Mono}(\tau) = \Gamma(x)) \\
        \mathcal C^\mathrm{let}(\Gamma', e) & (\mathrm{Poly}(\Gamma', e) = \Gamma(x)) \\
      \end{cases} \\
    \mathcal C^\mathrm{let}(\Gamma, e_1 \, e_2) &=
      \begin{array}[t]{l}
        \mathrm{let}
          \begin{array}[t]{l}
            (c_1, \tau_1) = \mathcal C^\mathrm{let}(\Gamma, e_1) \\
            (c_2, \tau_2) = \mathcal C^\mathrm{let}(\Gamma, e_2) \\
            \tau_3 = \mathrm{fresh}
          \end{array} \\
        \mathrm{in} (c_1 \cup c_2 \cup \{\tau_1 = \tau_2 \to \tau_3\}, \tau_3)
      \end{array} \\
    \mathcal C^\mathrm{let}(\Gamma, \lambda x . e) &=
      \begin{array}[t]{l}
        \mathrm{let}
          \begin{array}[t]{l}
            \tau_1 = \mathrm{fresh} \\
            (c, \tau_2) = \mathcal C^\mathrm{let}((\Gamma, x : \mathrm{Mono}(\tau_1)), e)
          \end{array} \\
        \mathrm{in} (c, \tau_1 \to \tau_2)
      \end{array} \\
    \mathcal C^\mathrm{let}(\Gamma, \letterm{x}{e_1}{e_2}) &=
      \mathcal C^\mathrm{let}((\Gamma, x : \mathrm{Poly}(\Gamma, e_1)), e_2)
  \end{align*}
  \caption{方程式の生成アルゴリズム $\mathcal C^\mathrm{let}$}
  \label{fig:algorithm-cp}
\end{figure}

アルゴリズム $\mathcal C$ からの主な変更点は三箇所です。

\begin{itemize}
  \item 項が変数であった場合に、それが単相の変数か多相の変数かによって計算が変わります。

        単相の変数であれば、型環境から得られる型をそのまま返します。
        多相の変数であれば、型環境から得られる型環境と項を用いて制約集合を生成します。

  \item $\lambda$ 抽象に関する制約の生成で、
        型環境に追加される情報が $\mathrm{Mono}(\tau)$ の形になる。

  \item let 項に対する制約の生成が追加されました。

        型環境 $\Gamma$ と $(\letterm{x}{e_1}{e_2})$ という項を取る場合、
        $\Gamma$ に変数 $x$ と $\mathrm{Poly}(\Gamma, e_1)$ の対応付けを追加した型環境を作り、
        その型環境と $e_2$ を使って制約の生成を行います。
\end{itemize}

これと第2章で示した単一化アルゴリズムを用いて、
$\lambda^\mathrm{let}$ 項に対する適切な型推論アルゴリズムを作れます。

\subsection{実装}

多相性を実現するための制約生成アルゴリズムを実装してみましょう。

$\lambda^\mathrm{let}$ 項のデータ型をリスト\ref{list:ocaml-def-ll-term}のように定義します。

\begin{lstlisting}[caption=$\lambda^\mathrm{let}$ 項の定義, label=list:ocaml-def-ll-term]
type term
  = EVar of string
  | EApp of (term * term)
  | EAbs of (string * term)
  | ELet of (string * term * term)
\end{lstlisting}

\texttt{ELet} コンストラクタが let 項のコンストラクタです。

型環境をリスト\ref{list:ocaml-def-poly-type-environment}のように定義します。

\begin{lstlisting}[caption=型環境の定義, label=list:ocaml-def-poly-type-environment]
type assump_elem
    = Monovar of ty
    | Polyvar of (assump_elem String.Map.t * term)
type assump = assump_elem String.Map.t
\end{lstlisting}

\texttt{assump\_elem} 型は型環境の一つの要素を表しています。

\texttt{Monovar} は単相変数用のコンストラクタ、\texttt{Polyvar} は多相変数用のコンストラクタです。

\texttt{assump} 型は型環境を表しています。
第2章での定義と違い、\texttt{assump\_elem} 型を用いていることに注意してください。

\texttt{constraints} 関数をリスト\ref{list:ocaml-poly-constraints}のように定義します。

\begin{lstlisting}[caption=制約の生成, label=list:ocaml-poly-constraints]
let rec constraints (n : int) (env : assump) :
    term -> (int * tconst list * ty) option =
  function
    | EVar str ->
      begin match String.Map.find env str with
        | Some (Monovar t) -> Some (n, [], t)
        | Some (Polyvar (env', term)) -> constraints n env' term
        | None -> None
      end
    | EApp (term1, term2) ->
      begin match constraints (succ n) env term1 with
        | Some (n1, c1, t1) ->
          begin match constraints n1 env term2 with
            | Some (n2, c2, t2) ->
              let tn = TVar n in
              Some (n2, (t1, TFun (t2, tn)) :: c1 @ c2, tn)
            | None -> None
          end
        | None -> None
      end
    | EAbs (ident, term) ->
      begin
        let tn = TVar n in
        let newenv = String.Map.add ident (Monovar tn) env in
        match constraints (succ n) newenv term with
          | Some (n', c, t) -> Some (n', c, TFun (tn, t))
          | None -> None
      end
    | ELet (ident, term1, term2) ->
      let newenv = String.Map.add ident (Polyvar (env, term1)) env in
      constraints n newenv term2
\end{lstlisting}

2章で示した \texttt{constraints} 関数からの変更点はアルゴリズムの変更と同様の三箇所です。
また、型環境の定義が少し違うものになっているため、
変数に関わる部分で \texttt{Monovar} や \texttt{Polyvar} が使われています。

\section{パラメトリック多相}

置き換えによる $\lambda^\mathrm{let}$ 項の型推論は、
この本で目標とする範囲の推論アルゴリズムと完全に一致しています。

しかし、この方法では時間的なコストが大きくなってしまう、
型が一致しないときに問題のある項を適切に示せないなどの問題があり、
多くの言語処理系では別の方法を採用しています。

ここでは、そのより良い方法である\textbf{パラメトリック多相 (parametric polymorphism)}
を用いた型付けの体系と、それに基いた推論アルゴリズムについて説明します。

パラメトリック多相の話に入るために、多相性の関わる項の例を幾つか考えてみます。

まずは、恒等関数 $\lambda x . x$ について考えましょう。
この項の最も広い意味での型は、$\alpha \to \alpha$ です。

$\letterm{i}{\lambda x . x}{\dots}$ のように書くことで、$\dots$ の中で恒等関数 $i$
を多相的に扱うことができます。このとき、その全ての $i$ の型はどれも $\tau_1 \to \tau_1$
の形をしているはずです。つまり、多相的な恒等関数は、任意の型 $\alpha$ に関して $\alpha \to \alpha$
という型を持つと言えます。パラメトリック多相では、このような型を記号 $\forall$ を用いて
$\forall \alpha . \alpha \to \alpha$ のように表記します。

この例のように、項 $e$ が型 $\tau$ で型付けできるとき、
項 $e$ に多相的に束縛された変数 $x$ は幾つかの任意の型に関して型 $\tau$ を持つと言えます。
項 $x$ の型は、変数 $x$ の型の任意の型全てに適切に型を代入することによって得られます。

さて、ここでどの型変数を任意の型として良いのかという問題がありますが、
全ての型変数を任意の型として良いわけではありません。

もう一つ、新しい例として直積型を含む体系ににおける
$\lambda a . \letterm{f}{\lambda b . (a, b)}{(f, f)}$ という項の型を考えてみましょう。

この項は、
$\alpha \to ((\gamma \to (\alpha \times \gamma)) \times (\delta \to (\alpha \times \delta)))$
で型付けでき、かつこれが最も一般的な型です。
これは二つの $f$ の直積を結果としていますが、それぞれの $f$ に相当する型は
$\gamma \to (\alpha \times \gamma)$ と $\delta \to (\alpha \times \delta)$ になっているため、
fの型は $\forall \beta . \beta \to (\alpha \times \beta)$ となっているはずです。
$\beta$ は任意の型となっていますが、$\alpha$ はなっていません。

これは、$\alpha$ が let の外側の型環境に含まれていることによる制限です。
外にもある型変数を勝手に付け替えてしまえば、型の整合性が取れなくなってしまいます。

よって、多相変数の束縛において $\forall$ の後に書かれる型変数は、その多相変数が束縛されている
項やその部分項の型以外の部分(let の外側の型環境)で出現してはいけないことになります。
この他に制約はありませんが、型中に一度も出現していない型変数を任意の型としてしまっても意味が無いので、
多相変数が束縛されている項の型に含まれ、かつその項やその部分項の型以外の部分で全く出現していない
型変数を任意の型として良いと考えるのが良いでしょう。

\subsection{理論}

単相の型のことを型と呼び、多相の($\forall$ の付いた)型のことを型スキームと呼びます。

型を記号 $\tau$ で表し、型スキームを記号 $\sigma$ で表します。
$\lambda^\mathrm{let}$ の型と型スキームを図\ref{fig:polymorphism-type}のように定義します。

\begin{figure}[htbp]
  \begin{align*}
    \tau   & \bnfcce  \alpha \\
           & \bnfvert (\tau \to \tau) \\
    \sigma & \bnfcce  \tau \\
           & \bnfvert \forall \alpha . \sigma
  \end{align*}
  \caption{$\lambda^\mathrm{let}$ の型}
  \label{fig:polymorphism-type}
\end{figure}

型に関しては今までと同様の省略規則を用います。型スキームに関して以下の省略規則を導入します。

\begin{enumerate}
  \item 型スキーム $\forall \alpha . \forall \beta . \dots \forall \gamma . \tau$ は、
        $\forall \alpha \beta \dots \gamma . \tau$ と省略できます。
\end{enumerate}

$\lambda^\mathrm{let}$ の型判定を図\ref{fig:poly-type-judgement}のように定義します。

\begin{figure}[htbp]
  \[
    \infere{T-Var}{
      \Gamma \vdash x : \sigma
    }{
      x : \sigma \in \Gamma
    }
  \]
  \[
    \infere{T-App}{
      \Gamma \vdash e_1 \, e_2 : \tau_2
    }{
      \Gamma \vdash e_1 : \tau_1 \to \tau_2 &
      \Gamma \vdash e_2 : \tau_1
    }
  \]
  \[
    \infere{T-Abs}{
      \Gamma \vdash \lambda x . e : \tau_1 \to \tau_2
    }
    {
      \Gamma, x : \tau_1 \vdash e : \tau_2
    }
  \]
  \[
    \infere{T-Let}{
      \Gamma \vdash \letterm{x}{e_1}{e_2} : \tau
    }{
      \Gamma \vdash e_1 : \sigma &
      \Gamma, x : \sigma \vdash e_2 : \tau
    }
  \]
  \[
    \infere{P-App}{
      \Gamma \vdash e : \sigma [\alpha := \tau]
    }{
      \Gamma \vdash e : \forall \alpha . \sigma
    }
  \]
  \[
    \infere{P-Abs}{
      \Gamma \vdash e : \forall \alpha . \sigma
    }{
      \Gamma \vdash e : \sigma &
      \alpha \notin FTV(\Gamma)
    }
  \]
  \caption{$\lambda^\mathrm{let}$ の型判定}
  \label{fig:poly-type-judgement}
\end{figure}

規則 \textsc{T-Let} は let 項に関する型付け規則です。

規則 \textsc{P-App} は型スキームの任意の型に具体的な型をあてはめ、型を単相にする規則です。

規則 \textsc{P-App} は型環境に含まれない型変数を任意の型とし、型を多相にする規則です。

これらの規則全体を見ると、規則 \textsc{P-App} は規則 \textsc{T-Var} の外側のみに、
規則 \textsc{P-Abs} は規則 \textsc{T-Let} の内側のみに出現すれば
十分に広い意味の型が付くことが分かります。

$\lambda^\mathrm{let}$ の型判定を図\ref{fig:poly-type-judgement2}のように定義し直すことができます。

\begin{figure}[htbp]
  \[
    \infere{T-Var}{
      \Gamma \vdash x : \tau_0 [\alpha := \tau_1, \dots, \beta := \tau_n]
    }{
      x : \forall \alpha \dots \beta . \tau_0 \in \Gamma
    }
  \]
  \[
    \infere{T-App}{
      \Gamma \vdash e_1 \, e_2 : \tau_2
    }{
      \Gamma \vdash e_1 : \tau_1 \to \tau_2 &
      \Gamma \vdash e_2 : \tau_1
    }
  \]
  \[
    \infere{T-Abs}{
      \Gamma \vdash \lambda x . e : \tau_1 \to \tau_2
    }
    {
      \Gamma, x : \tau_1 \vdash e : \tau_2
    }
  \]
  \[
    \infere{T-Let}{
      \Gamma \vdash \letterm{x}{e_1}{e_2} : \tau_2
    }{
      \Gamma \vdash e_1 : \tau_1 &
      \Gamma, x : \forall A . \tau_1 \vdash e_2 : \tau_2 &
      \forall \alpha \in A . \alpha \notin FTV(\Gamma)
    }
  \]
  \caption{$\lambda^\mathrm{let}$ の型判定}
  \label{fig:poly-type-judgement2}
\end{figure}

この型判定規則では、多相性の導入を \textsc{T-Let} 規則に含め、
多相性の除去を \textsc{T-Var} 規則に含むようにしました。

\subsection{アルゴリズム}

新しい $\lambda^\mathrm{let}$ の型判定規則を元に、
$\lambda^\mathrm{let}$ の型推論アルゴリズムを考えてみましょう。

パラメトリック多相を持つ型システムに対する型推論で最も重要なのは、多相型(型スキーム)を作る計算、
即ち多相にして良い型変数の集合の計算だと言えます。

多相にして良い型変数は let 項の外側の型環境に含まれない全ての型変数ですが、
多相にする型に含まれない型変数を多相にしてしまっても意味はありません。
よって、多相にする型に含まれる型変数のうち、
外側の型環境に含まれない全ての型変数を多相にすれば良いことが分かります。

しかし、2章で示したような制約の生成と制約解消を完全に分離した形の推論アルゴリズムでは、
制約の生成の途中で多相にして良い型変数を判定できず、型スキームを作る計算ができません。
この問題を解決するためには、型スキームを作る時点でその部分の制約を解消する必要があります。

制約生成で使う最も一般的な型スキームを作る関数 $\mathit{generalize}$ と型スキームを単相にする関数
$\mathit{instantiate}$ をそれぞれ図\ref{fig:generalize}と\ref{fig:instantiate}のように定義します。

\begin{figure}[htbp]
  \begin{align*}
    \mathit{generalize}(\Gamma, \tau) &= \forall (FTV(\tau) - FTV(\Gamma)) . \tau
  \end{align*}
  \caption{多相型を作る関数 $\mathit{generalize}$}
  \label{fig:generalize}
\end{figure}

\begin{figure}[htbp]
  \begin{align*}
    \mathit{instantiate}(\forall \alpha ... \beta . \tau) &=
      \tau [\alpha := \mathrm{fresh}, \dots, \beta := \mathrm{fresh}]
  \end{align*}
  \caption{多相型を単相にする関数 $\mathit{instantiate}$}
  \label{fig:instantiate}
\end{figure}

$\mathit{generalize}$ では、
型に含まれる型変数のうち型環境に含まれない型変数全てを任意の型とするように型スキームを作っています。

$\mathit{instantiate}$ では、
型スキームの任意の型全てにフレッシュな型を代入しています。

新しい型判定規則を用いた $\lambda^\mathrm{let}$ の制約生成アルゴリズム
$\mathcal C^\mathrm{let'}$ は図\ref{fig:algorithm-c-let2}のように定義できます。

\begin{figure}[htbp]
  \begin{align*}
    \mathcal C^\mathrm{let'}(\Gamma, x) &=
    \begin{cases}
      \mathit{failure}                          & (x \notin \mathit{dom}(\Gamma)) \\
      (\emptyset, \mathit{instantiate}(\sigma)) & (\sigma = \Gamma(x))
    \end{cases} \\
    \mathcal C^\mathrm{let'}(\Gamma, e_1 \, e_2) &=
    \begin{array}[t]{l}
      \mathrm{let}
        \begin{array}[t]{l}
          (c_1, \tau_1) = \mathcal C^\mathrm{let'}(\Gamma, e_1) \\
          (c_2, \tau_2) = \mathcal C^\mathrm{let'}(\Gamma, e_2) \\
          \tau_3 = \mathrm{fresh}
        \end{array} \\
      \mathrm{in} (c_1 \cup c_2 \cup \{\tau_1 = \tau_2 \to \tau_3\}, \tau_3)
    \end{array} \\
    \mathcal C^\mathrm{let'}(\Gamma, \lambda x . e) &=
    \begin{array}[t]{l}
      \mathrm{let}
        \begin{array}[t]{l}
          \tau_1 = \mathrm{fresh} \\
          (c, \tau_2) = \mathcal C^\mathrm{let'}((\Gamma, x : \tau_1), e)
        \end{array} \\
      \mathrm{in} (c, \tau_1 \to \tau_2)
    \end{array} \\
    \mathcal C^\mathrm{let'}(\Gamma, \letterm{x}{e_1}{e_2}) &=
    \begin{array}[t]{l}
      \mathrm{let}
        \begin{array}[t]{l}
          (c_1, \tau_1) = \mathcal C^\mathrm{let'}(\Gamma, e_1) \\
          \tau_1'       = \tau_1 \, \mathcal U(c_1) \\
          (c_2, \tau_2) = \mathcal C^\mathrm{let'}((\Gamma, x : \mathit{generalize(\Gamma, \tau_1')}) , e_2)
        \end{array} \\
      \mathrm{in} (c_1 \cup c_2, \tau_2)
    \end{array}
  \end{align*}
  \caption{方程式の生成アルゴリズム $\mathcal C^\mathrm{let'}$}
  \label{fig:algorithm-c-let2}
\end{figure}

このアルゴリズムでは、項が let 項であるときに多相になる項の制約生成で得られた制約を
アルゴリズム $\mathcal U$ によって解き、その結果を用いて多相型を作っています。

\section{$\mathcal W$}

\subsection{アルゴリズム}

アルゴリズム $\mathcal C^\mathrm{let'}$ では制約の生成の途中で一部分だけ制約を解くようにしましたが、
そうしてしまうのであれば制約集合を持っておく必要は無く、
制約はその場で解いてしまえば良いことになります。

そのようにして得られる $\lambda^\mathrm{let}$ の型推論アルゴリズムが $\mathcal W$ です。
アルゴリズム $\mathcal W$ は型環境と項のペアを取り、代入と型のペアを返します。
アルゴリズム $\mathcal W$ が返す代入は、
今までの制約生成アルゴリズムが返していた制約を解いたものに相当します。

アルゴリズム $\mathcal W$ の定義を図\ref{fig:algorithm-w}に示します。

\begin{figure}[htbp]
  \begin{align*}
    \mathcal W(\Gamma, x) &=
    \begin{cases}
      \mathit{failure} & (x \notin \mathit{dom}(\Gamma)) \\
      (\emptyset, \mathit{instantiate}(\sigma)) & (\sigma = \Gamma(x))
    \end{cases} \\
    \mathcal W(\Gamma, e_1 \, e_2) &=
    \begin{array}[t]{l}
      \mathrm{let}
        \begin{array}[t]{l}
          (s_1, \tau_1) = \mathcal W(\Gamma, e_1) \\
          (s_2, \tau_2) = \mathcal W(\Gamma \, s_1, e_2) \\
          \tau_3 = \mathrm{fresh} \\
          s_3 = \mathcal U(\{\tau_1 \, s_2 = \tau_2 \to \tau_3\})
        \end{array} \\
      \mathrm{in} (s_1 \cup s_2 \cup s_3, \tau_3 \, s_3)
    \end{array} \\
    \mathcal W(\Gamma, \lambda x. e) &=
    \begin{array}[t]{l}
      \mathrm{let}
        \begin{array}[t]{l}
          \tau_2 = \mathrm{fresh} \\
          (s_1, \tau_1) = \mathcal W((\Gamma, x : \tau_2), e) \\
        \end{array} \\
      \mathrm{in} (s_1, \tau_2 \, s_1 \to \tau_1)
    \end{array} \\
    \mathcal W(\Gamma, \letterm{x}{e_1}{e_2}) &=
    \begin{array}[t]{l}
      \mathrm{let}
        \begin{array}[t]{l}
          (s_1, \tau_1) = \mathcal W(\Gamma, e_1) \\
          (s_2, \tau_2) = \mathcal W((\Gamma \, s_1, x : \mathit{generalize}(\Gamma \, s_1, \tau_1)), e_2) \\
        \end{array} \\
      \mathrm{in} (s_1 \cup s_2, \tau_2)
    \end{array}
  \end{align*}
  \caption{型推論アルゴリズム $\mathcal W$}
  \label{fig:algorithm-w}
\end{figure}



\subsection{実装}



\section{まとめ}



